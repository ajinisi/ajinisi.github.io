<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-组成原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/组成原理/" class="article-date">
  <time datetime="2018-09-16T12:04:13.553Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/组成原理/">计算机组成原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="组成原理和体系结构"><a href="#组成原理和体系结构" class="headerlink" title="组成原理和体系结构"></a>组成原理和体系结构</h3><p>1.计算机体系结构Computer Architecture 主要研究硬件和软件功能的划分，确定硬件和软件的界面，即哪些功能应划分给硬件子系统完成，哪些功能应划分到软件子系统中完成．主通常是指涉及机器语言或者汇编语言的程序设计人员所见到的计算机系统的属性，更多说的是计算机的外特性，是硬件子系统的结构概念及其功能特性。</p>
<p>2.计算机组成原理<br>包括计算机系统概论；运算方法和运算器；存储系统；指令系统；中央处理器；总线；外围设备等 。是依据计算机体系结构确定并且分配了硬件子系统的概念结构和功能特性的基础上，设计计算机各部件的具体组成，它们之间的连接关系，实现机器指令级的各种功能和特性。从这一点又可以说，计算机组成是计算机体系结构的逻辑实现。 </p>
<p>微机原理：只是对非计算机专业的学生开的，大部分将8086的结构以及如何工作，还有汇编语言怎麼写。</p>
<p>计算机组成原理：探讨计算机的各个部分怎麼实现（电路）。</p>
<p>计算机体系结构讲的是在计算机组成原理的基础上，如何根据不同的场景和使用情况的设计计算机，以及各种设计的优缺点。</p>
<p>就拿缓存来说，计算机组成原理讲的是缓存怎麼做的（DRAM四个晶体管构成一个单元），而计算机体系结构讲的是缓存在cpu里怎么用（多级缓存，不同级别的缓存采用不同的寻址方式），才可以达到最大性能，不同使用方法的优缺点以及在实际中根据不同情况怎么折衷。</p>
<p>硬盘：在计算机组成原理里讲的硬盘怎么做的，磁头读写的物理机制，而计算机体系结构讲如何设计磁盘排列才能以最低的成本使发生意外数据损失的概率达到要求 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/组成原理/" data-id="cjw3crifz001i20uzjjg4t40y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/Web/" class="article-date">
  <time datetime="2018-09-16T11:55:35.168Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/Web/">Web开发之ajax原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</p>
<ol>
<li>使用CSS和XHTML来表示。</li>
<li>使用DOM模型来交互和动态显示。</li>
<li>使用XMLHttpRequest来和服务器进行异步通信。</li>
<li>使用javascript来绑定和调用。</li>
</ol>
<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/Web/" data-id="cjw3criea000v20uzo3b4q9h3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OOP_bind" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/OOP_bind/" class="article-date">
  <time datetime="2018-09-16T08:16:26.136Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/OOP_bind/">C++常见问题之绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>绑定：一个方法的调用与方法所在的类关联起来。java中的绑定分为静态绑定和动态绑定，又被称作前期绑定和后期绑定</p>
<p>静态绑定：（final、static、private）在程序执行前已经被绑定，也就是说在编译过程中就已经知道这个方法是哪个类的方法，此时由编译器获取其他连接程序实现。</p>
<p>静态绑定：编译时绑定， 通过对象调用 </p>
<p>动态绑定：在运行根据具体对象的类型进行绑定</p>
<p>动态绑定：运行时绑定，通过地址实现 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/OOP_bind/" data-id="cjw3cricw000f20uzvtd8cb28" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NET_address" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/NET_address/" class="article-date">
  <time datetime="2018-09-16T07:52:24.271Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/NET_address/">计算机网络复习之地址</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="IP地址和MAC地址的区别"><a href="#IP地址和MAC地址的区别" class="headerlink" title="IP地址和MAC地址的区别"></a>IP地址和MAC地址的区别</h3><p>1.对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变。</p>
<p>　　2. 长度不同。IP地址为32位，MAC地址为48位。</p>
<p>　　3. 分配依据不同。IP地址的分配是基于网络拓朴，MAC地址的分配是基于制造商。</p>
<p>　　4. 寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。</p>
<p>IP地址基于逻辑，比较灵活，不受硬件限制，也容易记忆。MAC地址在一定程度上与硬件一致，基于物理，能够标识具体。这两种地址各有好处，使用时也因条件而采取不同的地址</p>
<h3 id="IP地址与MAC地址在互连网中的作用"><a href="#IP地址与MAC地址在互连网中的作用" class="headerlink" title="IP地址与MAC地址在互连网中的作用"></a>IP地址与MAC地址在互连网中的作用</h3><p>既然每个以太网设备在出厂时都有一个唯一的MAC地址了，那为什么还需要为每台主机再分配一个IP地址呢？或者说为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：（1）IP地址的分配是根据网络的拓朴结构，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。（2）当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。（3）无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到MAC地址上来完成的。</p>
<p>这是由组网方式决定的，如今比较流行的接入Internet的方式（也是未来发展的方向）是把主机通过局域网组织在一起，然后再通过交换机和 Internet相连接。这样一来就出现了如何区分具体用户，防止盗用的问题。由于IP只是逻辑上标识，任何人都随意修改，因此不能用来标识用户；而 MAC地址则不然，它是固化在网卡里面的。从理论上讲，除非盗来硬件（网卡），否则是没有办法冒名顶替的（注意：其实也可以盗用，后面将介绍）。<br>基于MAC地址的这种特点，局域网采用了用MAC地址来标识具体用户的方法。注意：具体实现：在交换机内部通过“表”的方式把MAC地址和IP地址一一对应，也就是所说的IP、MAC绑定。<br>具体的通信方式：接收过程，当有发给本地局域网内一台主机的数据包时，交换机接收下来，然后把数据包中的IP地址按照“表”中的对应关系映射成MAC地址，转发到对应的MAC地址的主机上，这样一来，即使某台主机盗用了这个IP地址，但由于他没有这个MAC地址，因此也不会收到数据包。发送过程和接收过程类似，限于篇幅不叙述。<br>综上可知，只有IP而没有对应的MAC地址在这种局域网内是不能上网的，于是解决了IP盗用问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/NET_address/" data-id="cjw3cricm000c20uzvaltjei8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Shell之Linux命令运行的基本过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/Shell之Linux命令运行的基本过程/" class="article-date">
  <time datetime="2018-09-16T05:43:29.232Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/Shell之Linux命令运行的基本过程/">Shell之Linux命令运行的基本过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>shell不断询问是否有键盘输入，用户以enter结束键盘输入后，shell程序以空格为分隔符，得到”ls”，”-l”，”*.c”，三个字符串</p>
<p>shell发现第三个字符串包含”*”通配符，就会在当前路径(或指定路径)下搜索满足这个通配符的文件。有bar.c和foo.c两个文件，然后展开成{“ls”，”-l”，”bar.c”，”foo.c”}四个字符串，并保存在argv这个二维字符数组中，并赋值argc为4</p>
<p>shell然后搜索PATH这个全局变量保存的路径，寻找一个叫”ls”的命令。如果存在，则fork()一个子进程，调用exec()加载运行ls命令。ls的main(int argc, string ** argv)函数的参数就是从shell那里得来的。若不存在就会提示用户”command not found”</p>
<p>ls程序执行后，会分析argc和argv，”-l”表示这是一个选项开关，表明用户想得到文件的详细信息，并把这个开关量保存，以便最后输出的时候选择信息的格式</p>
<p>ls执行完既定的步骤后，退出并返回退出码，若成功则返回0，否则根据错误的不同返回不同的非零数字</p>
<p>shell在得到成功退出码后，继续等待用户输入</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/Shell之Linux命令运行的基本过程/" data-id="cjw3crie4000t20uzsjyc4fl7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learnDB7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/14/learnDB7/" class="article-date">
  <time datetime="2018-09-14T13:03:45.021Z" itemprop="datePublished">2018-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/14/learnDB7/">数据库的学习之主键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>使用最常查询的列或列 指定每个表的主键， 如果没有明显的主键，则指定 自动增量值</p>
<h4 id="主键的实现"><a href="#主键的实现" class="headerlink" title="主键的实现"></a>主键的实现</h4><ul>
<li>利用数据库递增，全数据库唯一：<br>单库单表，压力大<br>程序后台添加测试<br>旧数据导入<br>数据库迁移<br>缓存 (如，两个库中id都为2时，缓存的时候会覆盖)</li>
<li>UUID，生成32位的16进制字符串<br>无法排序</li>
<li>snowflake，twitter自己开发的</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>根据来自这些表的相同ID值从多个表中提取数据的位置 使用连接。要获得快速连接性能，请在连接列上定义 外键，并在每个表中声明具有相同数据类型的列。添加外键可确保对引用的列建立索引，从而提高性能。外键还会将删除或更新传播到所有受影响的表，如果父表中不存在相应的ID，则会阻止在子表中插入数据</p>
<p>关闭自动提交。每秒承诺数百次会限制性能（受存储设备写入速度的限制）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/14/learnDB7/" data-id="cjw3crif0001420uzz9anj0e2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/SQL/" class="article-date">
  <time datetime="2018-09-13T14:15:01.445Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/SQL/">SQL的学习之操作优先级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是FROM子句，尽管SELECT语句第一个出现，但是几乎总是最后被处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( 8 ) SELECT ( 9 ) DISTINCT ( 11 ) &lt; Top Num &gt; &lt; select list &gt; </span><br><span class="line">( 1 ) FROM [ left_table ] </span><br><span class="line">( 3 ) &lt; join_type &gt; JOIN &lt; right_table &gt; </span><br><span class="line">( 2 ) ON &lt; join_condition &gt; </span><br><span class="line">( 4 ) WHERE &lt; where_condition &gt; </span><br><span class="line">( 5 ) GROUP BY &lt; group_by_list &gt; </span><br><span class="line">( 6 ) WITH &lt; CUBE | RollUP &gt; </span><br><span class="line">( 7 ) HAVING &lt; having_condition &gt; </span><br><span class="line">( 10 ) ORDER BY &lt; order_by_list &gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>FROM：对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1</li>
<li>ON：对VT1应用ON筛选器。只有那些使为真的行才被插入VT2。</li>
<li>OUTER(JOIN)：如果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。</li>
<li>WHERE：对VT3应用WHERE筛选器。只有使为true的行才被插入VT4.</li>
<li>GROUP BY：按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.</li>
<li>CUBE|ROLLUP：把超组(Suppergroups)插入VT5,生成VT6.</li>
<li>HAVING：对VT6应用HAVING筛选器。只有使为true的组才会被插入VT7.</li>
<li>SELECT：处理SELECT列表，产生VT8.</li>
<li>DISTINCT：将重复的行从VT8中移除，产生VT9.</li>
<li>ORDER BY：将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).</li>
<li>TOP：从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。</li>
</ol>
<p>每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回 给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。</p>
<p>注：步骤10，按ORDER BY子句中的列列表排序上步返回的行，返回游标VC10.这一步是第一步也是唯一一步可以使用SELECT列表中的列别名的步骤。这一步不同于其它步骤的 是，它不返回有效的表，而是返回一个游标。SQL是基于集合理论的。集合不会预先对它的行排序，它只是成员的逻辑集合，成员的顺序无关紧要。对表进行排序 的查询可以返回一个对象，包含按特定物理顺序组织的行。ANSI把这种对象称为游标。理解这一步是正确理解SQL的基础</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/13/SQL/" data-id="cjw3cried000w20uz60hm9uxx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-组成原理_ROM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/组成原理_ROM/" class="article-date">
  <time datetime="2018-09-12T13:27:54.958Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/组成原理_ROM/">计算机组成原理之ROM和RAM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RAM是易失性存储器，ROM是非易失性存储器<br>RAM和ROM都是采用随机存取的方式进行信息访问<br>RAM是随机存储器<br>ROM是只读存储器 </p>
<p>RAM掉电不会保存数据，而ROM可以在掉电的情况下，依然保存原有的数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/组成原理_ROM/" data-id="cjw3crig1001j20uz6rel7uvn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/OOP/" class="article-date">
  <time datetime="2018-09-12T07:08:48.483Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/OOP/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先介绍一些基本概念</p>
<h3 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h3><p>这两个概率是对于成员函数来说的，接口即是“函数声明”，实现即是“函数定义”。接口是公开的，实现是封装的。接口就是可供外部调用的方法，实现就是内部对这些方法的实现。</p>
<p>接口：接口由使用该类的代码需要执行的操作组成<br>实现：实现一般包括该类所需要的数据，实现还包括定义该类需要的但又不供一般性使用的函数<br>定义类的数据成员和定义普通变量有些相似，：一般不能把类成员的初始化作为其定义的一部分</p>
<h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><p>虚函数：即使是空实现，留给子类去覆盖，提供默认的函数实现<br>纯虚函数：只是个接口，留到子类去实现，抽象类不能直接生成对象，例如“动物”</p>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>抽象类abstract class<br>接口interface在C++中用抽象类来实现，在C#和Java中专门用interface来实现</p>
<h4 id="Java中的抽象类和接口"><a href="#Java中的抽象类和接口" class="headerlink" title="Java中的抽象类和接口"></a>Java中的抽象类和接口</h4><p>为什么Java中会专门弄个接口这个概率呢？首先java是不支持多重继承的，一个类只能extends一个抽象类，但是可以implements多个接口。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑。</p>
<p>抽象类和接口主要体现在设计理念上，抽象类体现的是“is a”关系，而接口体现的是“like a”关系</p>
<p>举个例子，实现一个报警门，方法有开、关和报警，为了ISP原则，我们要把开关和报警分开，由于Java不支持多重继承，我们只能是设计两个接口或者一个抽象类一个接口。这两个方案都是可以的，但是后者更能体现报警门是一个带有报警功能的门，而不是一个带有开关和报警的东西。</p>
<p>PS：例子来自网上，用我自己的话说了一遍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Demo_A &#123;</span><br><span class="line">    abstract void method1();    </span><br><span class="line">    abstract void method2();    </span><br><span class="line">    …   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Demo_I &#123; </span><br><span class="line">    void method1();    </span><br><span class="line">    void method2();    </span><br><span class="line">    …    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-中的抽象类和接口"><a href="#C-中的抽象类和接口" class="headerlink" title="C++中的抽象类和接口"></a>C++中的抽象类和接口</h4><p>在面向对象编程中，抽象类是一种只能定义类型，不能生成对象的类，它是对一系列看上去不同，但是本质相同的具体概念的抽象。要实现抽象类则需要通过纯虚函数实现。</p>
<p>C++的接口是一种特殊的抽象类，需要满足： </p>
<ul>
<li>类中没有定义任何成员变量 </li>
<li>类中所有成员函数都是公有且都是纯虚函数<br>所以，也有用“纯抽象类”这个词来表示接口</li>
</ul>
<p>C++之父还抱怨过为什么这么简单的差别有的人不理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/OOP/" data-id="cjw3cricz000g20uz2o27bvtq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learnDB_index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/learnDB_index/" class="article-date">
  <time datetime="2018-09-12T02:10:23.910Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/learnDB_index/">数据库的学习之索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><p>索引是一种特殊的数据库结构，可以用来快速查询数据库表中的特定记录<br>是存储引擎用于快速找到记录的一种数据结构<br>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针</p>
<h4 id="索引的位置"><a href="#索引的位置" class="headerlink" title="索引的位置"></a>索引的位置</h4><p>索引存储在硬盘中的，MYSQL需要的时侯调入部分内容到内存</p>
<p>在内存里，索引肯定是以BST，Trie，Hashtable等形式存在，便于查找。在磁盘上的存储呢？<br>1）不要想到树的序列化问题，不一样，第一，索引是先在磁盘后load到内存里，第二，树的序列化是说要完全保存树的结构，这里不需要，只需要是一颗平衡树就行。<br>2）其实就是一个symbol table，词典，key-value 表，在磁盘上时候不需要有序，只要相关数据保存到了就可以了，load的过程就是给定一个词典建一棵Trie树的问题。只需要从一棵空trie开始，(key,value)做一个结点，不断插入入到Trie里（或者 BST ，hash table）。<br>3）MDS对索引的存储是用xml 把trie的结构也保存了下来，不是为了存储这个树结构本身，而是为了利用Trie的特点，相同前缀只出现一次，公共前缀多的情况下节省存储。当然xml又有overhead，未必真的能节省，但思路是这样。在磁盘上保存树的结构，并不能加速load。</p>
<p>360二面的时候问我索引是在磁盘上还是内存中</p>
<h3 id="应该-不应该建立索引"><a href="#应该-不应该建立索引" class="headerlink" title="应该/不应该建立索引"></a>应该/不应该建立索引</h3><h4 id="应该建立索引"><a href="#应该建立索引" class="headerlink" title="应该建立索引"></a>应该建立索引</h4><ul>
<li>表的主键、外键必须有索引；</li>
<li>数据量超过300的表应该有索引；</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li>
<li>为常作为查询条件的字段建立索引，经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>索引应该建在选择性高的字段上；</li>
<li>为经常需要排序、分组和联合操作的字段建立索引 </li>
</ul>
<h4 id="不应该建立索引"><a href="#不应该建立索引" class="headerlink" title="不应该建立索引"></a>不应该建立索引</h4><ul>
<li><p>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求</p>
</li>
<li><p>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度</p>
</li>
<li><p>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少</p>
</li>
<li><p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当对修改性能的要求远远大于检索性能时，不应该创建索引</p>
</li>
</ul>
<h3 id="？？"><a href="#？？" class="headerlink" title="？？"></a>？？</h3><h4 id="怎么设计索引"><a href="#怎么设计索引" class="headerlink" title="怎么设计索引"></a>怎么设计索引</h4><ul>
<li><p>尽量使用数据量少的索引。尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。 这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了 </p>
</li>
<li><p>尽量使用前缀来索引 </p>
</li>
<li><p>选择惟一性索引</p>
</li>
<li><p>限制索引的数目：索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率， 因为 insert 或 update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要</p>
</li>
<li><p>删除不再使用或者很少使用的索引</p>
</li>
</ul>
<h4 id="怎么使用索引"><a href="#怎么使用索引" class="headerlink" title="怎么使用索引"></a>怎么使用索引</h4><ul>
<li><p>避免对索引字段进行计算操作；</p>
</li>
<li><p>避免在索引字段上使用not、&lt;&gt;、!=：可能导致不走索引，也可能走 INDEX FAST FULL SCAN<br>例如select id  from test where id&lt;&gt;100 </p>
</li>
<li><p>避免在索引字段单使用 IS NULL、IS NOT NULL；</p>
</li>
<li><p>避免在索引字段单出现数据类型转换：索引不适用于隐式转换的情况，比如你的SELECT <em> FROM T WHERE Y = 5 在Y上面有一个索引，但是Y列是VARCHAR2的，那么Oracle会将上面的5进行一个隐式的转换，SELECT </em> FROM T WHERE TO_NUMBER(Y) = 5,这个时候也是有可能用不到索引的</p>
</li>
<li><p>避免在索引字段上使用函数：如果在T表上有一个索引Y，但是你的查询语句是这样子SELECT * FROM T WHERE FUN(Y) = XXX。这个时候索引也不会被用到，因为你要查询的列中所有的行都需要被计算一遍，因此，如果要让这种sql语句的效率提高的话，在这个表上建立一个基于函数的索引，比如CREATE INDEX IDX FUNT ON T(FUN(Y));这种方式，等于Oracle会建立一个存储所有函数计算结果的值，再进行查询的时候就不需要进行计算了，因为很多函数存在不同返回值，因此必须标明这个函数是有固定返回值的</p>
</li>
</ul>
<ul>
<li>避免建立索引的列中使用空值：单键值的B树索引列上存在null值，导致COUNT(<em>)不能走索引。<br>如果在B树索引中有一个空值，那么查询诸如SELECT COUNT(</em>) FROM T 的时候，因为HASHSET中不能存储空值的，所以优化器不会走索引，有两种方式可以让索引有效，一种是SELECT COUNT(*) FROM T WHERE XXX IS NOT NULL或者把这个列的属性改为not null (不能为空)</li>
</ul>
<p>以上情况发生时不会使用索引。除此之外，还有</p>
<p>如果MySQL估计使用索引比全表扫描更慢，则不适用索引，<br>ex：列key_part1均匀的分布在1-100之间。下面的sql则不会使用索引<br>select * from table_name where key_part1 &gt; 1 and key_part1 &lt;90</p>
<p>用or分割开的条件，如果or左右两个条件中有一个列没有索引，则不会使用索引。<br>ex：select * from table_name where key1=’a’ or key2=’b’；<br>如果在key1上有索引而在key2上没有索引，则该查询也不会走索引</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/learnDB_index/" data-id="cjw3crifg001920uzv6b0m62w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/25/Redis之简单介绍/">Redis之简单介绍（The Simple Introduction for Redis）</a>
          </li>
        
          <li>
            <a href="/2019/04/03/字符串的使用问题/">字符串的使用问题</a>
          </li>
        
          <li>
            <a href="/2018/11/04/math/">数学</a>
          </li>
        
          <li>
            <a href="/2018/10/28/计算机网络复习之gfw/">计算机网络复习之gfw</a>
          </li>
        
          <li>
            <a href="/2018/10/23/shortcuts/">快捷键</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>