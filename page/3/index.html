<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CPPGram_return" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/CPPGram_return/" class="article-date">
  <time datetime="2018-09-16T01:20:10.795Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/CPPGram_return/">C++常见问题之return</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><h4 id="如何在main-函数之前执行操作"><a href="#如何在main-函数之前执行操作" class="headerlink" title="如何在main()函数之前执行操作"></a>如何在main()函数之前执行操作</h4><p>main函数执行之前，主要就是初始化系统相关资源：<br>设置栈指针<br>初始化static静态和global全局变量，即data段的内容<br>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容<br>全局对象初始化，在main之前调用构造函数<br>将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数</p>
<h4 id="如何在main-函数之后执行操作"><a href="#如何在main-函数之后执行操作" class="headerlink" title="如何在main()函数之后执行操作"></a>如何在main()函数之后执行操作</h4><p>main函数执行之后：<br>全局对象的析构函数会在main函数之后执行；<br>可以用_onexit 注册一个函数，它会在main 之后执行; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int atexit(void (*function&quot;)(void));</span><br><span class="line">void fn1( void ), fn2( void ), fn3( void );</span><br><span class="line"></span><br><span class="line">int main( void )&#123;</span><br><span class="line">    onexit( fn1 );</span><br><span class="line">    onexit( fn2 );</span><br><span class="line">    printf( &quot;This is executed first.&quot; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fn1()&#123;</span><br><span class="line">    printf( &quot; This is&quot; );</span><br><span class="line">&#125;</span><br><span class="line">void fn2()&#123;</span><br><span class="line">    printf( &quot; executed next.&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br>This is executed first.<br>This is executed next. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	A()</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;A()\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	~A()</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;~A()\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">bool b = false;</span><br><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">	if (!b)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;init now!\n&quot;);</span><br><span class="line">		b = true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;uninit now\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef int (__cdecl *_PVFV)();</span><br><span class="line">#pragma section(&quot;.CRT$XIU&quot;, long, read)</span><br><span class="line">#pragma section(&quot;.CRT$XPU&quot;, long, read)</span><br><span class="line">__declspec(allocate(&quot;.CRT$XIU&quot;)) _PVFV mgt_startup[] = &#123; foo &#125;;</span><br><span class="line">__declspec(allocate(&quot;.CRT$XPU&quot;)) _PVFV mgt_exit[] = &#123; foo &#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;main.!\n&quot;);</span><br><span class="line">	//exit(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 init  A() main() ~A() uninit 这样的顺序</p>
<h3 id="return"><a href="#return" class="headerlink" title="return;"></a>return;</h3><p>return：C语言九大控制流程语句之一<br>格式：return; return value;<br>第一种用法用于空（void）函数中，用于强制结束函数，但什么也不返回。相当return void;<br>第二种用法用于带返回值的函数中，用于强制结束函数，返回value。value的类型必须和函数的返回值类型一致 </p>
<p>• 若控制流抵达返回 void （可有 cv 限定）的函数结尾、构造函数结尾、析构函数结尾，或对于返回 void （可有 cv 限定）的函数的函数 try 块结尾，则执行 return; 。<br>• 若控制流抵达 main 函数的结尾，则执行 return 0; 。<br>• 流经有返回值的函数（除了 main ）的函数尾而不经过 return 语句是未定义行为。<br>• 若函数返回 void ，则可以用带 表达式 的 return 语句，若表达式类型为 void</p>
<p>就是回到调用函数处，call的下一跳指令<br>返回到调用该函数的地址继续往下执行，也就是让EIP的值指向调用这个函数的下一条指令 </p>
<h3 id="return-0-和return-1"><a href="#return-0-和return-1" class="headerlink" title="return 0;和return -1"></a>return 0;和return -1</h3><p>return 0：一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数。<br>return -1：:表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯例，表示该函数失败；<br>以上两个是约定俗成，系统提供的函数绝大部分定义为int类型返回值的都是这样的。返回值是返回给系统用的，给系统看得。一般做调试的时候也会用的，当出现错误的时候可以根据返回值来确定问题出在哪一个函数上的</p>
<h3 id="break和return"><a href="#break和return" class="headerlink" title="break和return"></a>break和return</h3><p>break是用来跳出循环的，例如for，while，do-while都可以跳出，但不跳出函数<br>return是使整个函数返回的，后面的不管是循环里面还是循环外面的都不执行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/CPPGram_return/" data-id="cjm8rmk320007rguz19zdlfmy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP_memory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/15/CPP_memory/" class="article-date">
  <time datetime="2018-09-15T12:07:37.906Z" itemprop="datePublished">2018-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/15/CPP_memory/">C常见问题之内存布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="堆区和栈区"><a href="#堆区和栈区" class="headerlink" title="堆区和栈区"></a>堆区和栈区</h3><p>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；</p>
<p>堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些</p>
<p>堆区就是各种慢，申请内存慢，访问慢，修改慢，释放慢，整理慢（或者说GC垃圾回收），但优点也不言而喻，访问随机灵活，空间超大，在不超可用内存的情况下你要多大就给多大。</p>
<p>栈区就像临时工，干完就跑，所以超快，但是缺点也很多，比如生命周期短，一般只能在一个方法内存活，又比如你需要事先知道需要多大的栈（事实上绝大多数语言栈区要分配的大小编译期就确定了，Java就是这样），而且通常最大栈区可用内存都很小，你不可能往栈区里堆很多数据</p>
<p>栈区的好处还包括是每次方法调用的入栈和出栈，都意味着栈桢的创建和销亡，省去了资源回收的操作</p>
<p>栈区是线程独享的。<br>堆区是线程共享的。</p>
<p>总结：<br>1、管理方式不同；<br>    2、空间大小不同；<br>    3、能否产生碎片不同；<br>    4、生长方向不同；<br>    5、分配方式不同；<br>    6、分配效率不同；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char s1[] = &quot;aaaaaaaaaaaaaaa&quot;;  </span><br><span class="line">char *s2 = &quot;bbbbbbbbbbbbbbbbb&quot;;  </span><br><span class="line">aaaaaaaaaaa是在运行时刻赋值的；  </span><br><span class="line">而bbbbbbbbbbb是在编译时就确定的；  </span><br><span class="line">但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。  </span><br><span class="line">比如：  </span><br><span class="line">#include  </span><br><span class="line">void main()  </span><br><span class="line">&#123;  </span><br><span class="line">char a = 1;  </span><br><span class="line">char c[] = &quot;1234567890&quot;;  </span><br><span class="line">char *p =&quot;1234567890&quot;;  </span><br><span class="line">a = c[1];  </span><br><span class="line">a = p[1];  </span><br><span class="line">return;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码<br>10: a = c[1];<br>00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]<br>0040106A 88 4D FC mov byte ptr [ebp-4],cl<br>11: a = p[1];<br>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]<br>00401070 8A 42 01 mov al,byte ptr [edx+1]<br>00401073 88 45 FC mov byte ptr [ebp-4],al  </p>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到<br>edx中，再根据edx读取字符，显然慢了</p>
<h3 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a>常量存储区</h3><p>这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/15/CPP_memory/" data-id="cjm8rmk340009rguzbczvozvh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPPGram_memcpy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/15/CPPGram_memcpy/" class="article-date">
  <time datetime="2018-09-15T01:31:13.793Z" itemprop="datePublished">2018-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/15/CPPGram_memcpy/">C++常见问题之memcpy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>memcpy这个函数在C/C++编程领域中使用率是比较高的（可能排在前10左右）</p>
<h3 id="memcpy的实现"><a href="#memcpy的实现" class="headerlink" title="memcpy的实现"></a>memcpy的实现</h3><p>首先确定函数原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *dest, const void *src, size_t count);</span><br></pre></td></tr></table></figure></p>
<p>源地址和目标地址的指针都是void *型的，也就是可以传入任何类型的指针，因为这里要执行的操作和指针类型没有任何关系，只需要知道起点和大小。</p>
<p>开始复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void *memcpy(void *dest, const void *src, size_t count)&#123;</span><br><span class="line">if (NULL == dest || NULL == src || count &lt;= 0)</span><br><span class="line">    return NULL;</span><br><span class="line">void* ptr=dest;</span><br><span class="line">while (count--)</span><br><span class="line">    *dest++ = *src++;</span><br><span class="line">return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码在Linux中使用gcc编译是没错的,但是会有警告，因为C里要访问内存必须指定一个具体的类型，告诉编译器要访问多大的空间，对指向空的指针void*进行解引用是非法的。</p>
<p>按照ANSI(American National Standards Institute)标准，也不能对void指针进行算法操作，即不能对void指针进行如p++的操作,所以需要转换为具体的类型指针来操作,例如char *</p>
<p>所以我们可以采取的是逐字节复制的方法，使用char <em>来访问，另外用char </em>比较简便，使用int *来访问的话，你无法保证要复制的大小是偶数，这样还得加个判断</p>
<p>同时，size_t是无符号类型的,size_t的定义为：typedef unsigned int size_t;<br>所以count&lt;=0,只会判断==0的情况。如果你传入-1,会产生一个很大的无符号整型，是可以通过判断的</p>
<p>现在修改代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void* memcpy(void *dest, const void* src, size_t count)&#123;</span><br><span class="line">	int size=count;</span><br><span class="line">    if(dest == NULL || src == NULL || size &lt;= 0)</span><br><span class="line">		return dest;</span><br><span class="line">	char* dest_pos = (char *)dest;</span><br><span class="line">	char* src_pos = (char *)src;</span><br><span class="line">	while(size--)</span><br><span class="line">		*dest_pos++ = *src_pos++;</span><br><span class="line">	return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果嫌弃一个一个字节地复制太慢，可以采用下面的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void * memcpy(void *dest,const void *src,size_t num)&#123;</span><br><span class="line">	int nchunks = num/sizeof(dest);   /*按CPU位宽拷贝*/</span><br><span class="line">	int slice = num%sizeof(dest);   /*剩余的按字节拷贝*/</span><br><span class="line"></span><br><span class="line">	unsigned long * s = (unsigned long *)src;</span><br><span class="line">	unsigned long * d = (unsigned long *)dest;</span><br><span class="line"></span><br><span class="line">	while(nchunks--)</span><br><span class="line">	    *d++ = *s++;</span><br><span class="line">	while (slice--)</span><br><span class="line">	    *((char *)d++) =*((char *)s++);</span><br><span class="line"></span><br><span class="line">	return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="memmove的实现"><a href="#memmove的实现" class="headerlink" title="memmove的实现"></a>memmove的实现</h3><p>内存重叠问题是指目的地址的内存空间的首地址，包含在源内存空间中，这两段内存空间有了交集，因而在使用memcpy进行内存复制操作时，这段重叠的内存空间会被破坏。<br>现在要考虑内存重叠的情况，我们要兼容向前拷贝和向后拷贝、不同BUF拷贝的情况，也近似C函数库的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void* memmove(void *dest, const void* src, size_t count)&#123;</span><br><span class="line">	int size=count;</span><br><span class="line">	if(dest == NULL || src == NULL || size &lt;= 0)</span><br><span class="line">		return dest;</span><br><span class="line">	char* dest_pos = (char *)dest;</span><br><span class="line">	char* src_pos = (char *)src;</span><br><span class="line"></span><br><span class="line">	if(dest_pos &lt; src_pos + size &amp;&amp; dest &gt; src)&#123; // DOWN COPY，从后向前拷贝</span><br><span class="line">		dest_pos = dest_pos + size - 1;</span><br><span class="line">		src_pos = src_pos + size - 1;</span><br><span class="line">		while(size--)</span><br><span class="line">			*(dest_pos--) = *(src_pos--);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123; // UP COPY，从前向后拷贝</span><br><span class="line">		while(size--)</span><br><span class="line">			*(dest_pos++) = *(src_pos++);</span><br><span class="line">	&#125;</span><br><span class="line">	return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol>
<li>如果复制的字节数n超出了dest的空间容量，或者n超出src的容量，这个函数是不会进行判断的，这样就会很危险。需要程序员自己检查是否有溢出的情况出现。</li>
<li>这个函数不会检查参数dest与参数src所指向的数组（或其他类型）是否具有同样的空间。</li>
<li>memcpy, memset等函数都是对内存操作的函数，效率很高，当然也很容易出现问题；如果出现src -&gt; dest的大小出现问题，src地址大于dest地址，就会存在dest无法存取完整数据，造成src数据丢下。memcpy本身是有bug的，并没有解决覆盖问题，可以选用memmove代替。</li>
</ol>
<p>注意：memmove这个函数名称中有”move”这个单词,而实际上src处的数据仍然还在,并没有真的被”移动”了!这个函数名称有它的历史原因,是因为有了memcpy函数后,发现这个函数有问题,又发明了另一个没有问题的memcpy函数,但为了兼容性依然保留了memcpy函数,而将新版本的memcpy函数改名为memmove函数.</p>
<ol start="4">
<li>在C++中，我们把传统C风格的数据类型叫做POD（Plain Old Data）对象，即一种古老的纯数据。在C的世界里根本没有POD这一概念，因为C的所有对象都是POD。一般来说，POD对象应该满足如下特性：其二进制内容是可以随意复制的，无论在什么地方，只要其二进制内容存在，我们就能准确无误地还原出POD对象。正是由于这个原因，对于任何POD对象，我们都可以放心大胆地使用memset()、memcpy()、memcmp()等函数对对象的内存数据进行操作。然而在C++中，每个人都要十二分的注意了。因为C++的对象可能并不是一个POD，所以我们无法像在C中那样获得该对象直观简洁的内存模型。对于POD对象，我们可以通过对象的基地址和数据成员的偏移量获得数据成员的地址。但是C++标准并未对非POD对象的内存布局做任何定义，对于不同的编译器，其对象布局是不同的。而在C语言中，对象布局仅仅会受到底层硬件系统差异的影响。针对非POD对象，其序列化会遇到一定的障碍：由于对象的不同部分可能存在于不同的地方，因而无法直接复制，只能通过手工加入序列化操作代码来处理对象数据，很麻烦。但是针对POD对象，这一切将变得不再困难：从基地址开始，直接按对象的大小复制数据，或传输，或存储，随意处理。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/15/CPPGram_memcpy/" data-id="cjm8rmk310005rguzakw2h7bn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learnDB7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/14/learnDB7/" class="article-date">
  <time datetime="2018-09-14T13:03:45.021Z" itemprop="datePublished">2018-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/14/learnDB7/">数据库的学习之主键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>使用最常查询的列或列 指定每个表的主键， 如果没有明显的主键，则指定 自动增量值</p>
<h4 id="主键的实现"><a href="#主键的实现" class="headerlink" title="主键的实现"></a>主键的实现</h4><ul>
<li>利用数据库递增，全数据库唯一：<br>单库单表，压力大<br>程序后台添加测试<br>旧数据导入<br>数据库迁移<br>缓存 (如，两个库中id都为2时，缓存的时候会覆盖)</li>
<li>UUID，生成32位的16进制字符串<br>无法排序</li>
<li>snowflake，twitter自己开发的</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>根据来自这些表的相同ID值从多个表中提取数据的位置 使用连接。要获得快速连接性能，请在连接列上定义 外键，并在每个表中声明具有相同数据类型的列。添加外键可确保对引用的列建立索引，从而提高性能。外键还会将删除或更新传播到所有受影响的表，如果父表中不存在相应的ID，则会阻止在子表中插入数据</p>
<p>关闭自动提交。每秒承诺数百次会限制性能（受存储设备写入速度的限制）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/14/learnDB7/" data-id="cjm8rmk3u000trguz3vqa0i6s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/SQL/" class="article-date">
  <time datetime="2018-09-13T14:15:01.445Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/SQL/">SQL的学习之操作优先级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是FROM子句，尽管SELECT语句第一个出现，但是几乎总是最后被处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( 8 ) SELECT ( 9 ) DISTINCT ( 11 ) &lt; Top Num &gt; &lt; select list &gt; </span><br><span class="line">( 1 ) FROM [ left_table ] </span><br><span class="line">( 3 ) &lt; join_type &gt; JOIN &lt; right_table &gt; </span><br><span class="line">( 2 ) ON &lt; join_condition &gt; </span><br><span class="line">( 4 ) WHERE &lt; where_condition &gt; </span><br><span class="line">( 5 ) GROUP BY &lt; group_by_list &gt; </span><br><span class="line">( 6 ) WITH &lt; CUBE | RollUP &gt; </span><br><span class="line">( 7 ) HAVING &lt; having_condition &gt; </span><br><span class="line">( 10 ) ORDER BY &lt; order_by_list &gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>FROM：对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1</li>
<li>ON：对VT1应用ON筛选器。只有那些使为真的行才被插入VT2。</li>
<li>OUTER(JOIN)：如果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。</li>
<li>WHERE：对VT3应用WHERE筛选器。只有使为true的行才被插入VT4.</li>
<li>GROUP BY：按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.</li>
<li>CUBE|ROLLUP：把超组(Suppergroups)插入VT5,生成VT6.</li>
<li>HAVING：对VT6应用HAVING筛选器。只有使为true的组才会被插入VT7.</li>
<li>SELECT：处理SELECT列表，产生VT8.</li>
<li>DISTINCT：将重复的行从VT8中移除，产生VT9.</li>
<li>ORDER BY：将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).</li>
<li>TOP：从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。</li>
</ol>
<p>每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回 给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。</p>
<p>注：步骤10，按ORDER BY子句中的列列表排序上步返回的行，返回游标VC10.这一步是第一步也是唯一一步可以使用SELECT列表中的列别名的步骤。这一步不同于其它步骤的 是，它不返回有效的表，而是返回一个游标。SQL是基于集合理论的。集合不会预先对它的行排序，它只是成员的逻辑集合，成员的顺序无关紧要。对表进行排序 的查询可以返回一个对象，包含按特定物理顺序组织的行。ANSI把这种对象称为游标。理解这一步是正确理解SQL的基础</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/13/SQL/" data-id="cjm8rmk3s000qrguzhsa381it" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPPGram_new" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/CPPGram_new/" class="article-date">
  <time datetime="2018-09-13T12:37:58.919Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/CPPGram_new/">C++常见问题之new和delete</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在前面的博客提到过new和malloc的比较。如果继续深入下去还有一些有意思的事情。</p>
<h3 id="new的实现机制"><a href="#new的实现机制" class="headerlink" title="new的实现机制"></a>new的实现机制</h3><p>new 会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete 先调用析构函数，然后调用operator delete 函数释放内存（通常底层使用free实现）<br>因此，new可以认为是malloc+构造函数</p>
<h3 id="new一个数组"><a href="#new一个数组" class="headerlink" title="new一个数组"></a>new一个数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *_p =malloc(sizeof(Super))</span><br><span class="line">((Super*)_p)-&gt;Super();</span><br><span class="line">sp1 =(Super*)_p;</span><br></pre></td></tr></table></figure>
<p>operator new []和operator new是有差别的，operator new []会使用malloc函数一次性申请好此次操作+4个字节大小的内存空间，然后依据本次申请的对象数，循环调用数组内各个对象的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count =15;</span><br><span class="line">size =sizeof(Super)</span><br><span class="line">void * _p =malloc(Count*Size+4)</span><br><span class="line">void * tp =(void *)(((char*)p)+4)</span><br><span class="line">for I in 0..15:</span><br><span class="line">    tp=(void*)(((char*)tp)+Size*I)</span><br><span class="line">    ((Super*)tp)-&gt;Super();</span><br><span class="line">*(int*)_p=Count</span><br><span class="line">Sp =(Super*)((int*)_p+1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count =*(((int*)sp)-1)</span><br><span class="line">for I in 0..count:</span><br><span class="line">    (Sp+i)-&gt;~Super()</span><br><span class="line">free(void*(((int*)sp)-1))</span><br></pre></td></tr></table></figure>
<p>delete []的工作原理是先把参数向后偏移4个字节，得到后续元素个数，然后在一个循环中依次调用各元素的析构函数，最后再调用free()函数，其中传递给free的是偏移之后的地址。<br>delete 的工作原理很简单，调用参数的析构函数，然后在把这个地址无需偏移传递给free.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(sp1)-&gt;~Super()</span><br><span class="line">free(sp1)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/13/CPPGram_new/" data-id="cjm8rmk300004rguzy2967ha7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-组成原理_ROM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/组成原理_ROM/" class="article-date">
  <time datetime="2018-09-12T13:27:54.958Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/组成原理_ROM/">计算机组成原理之ROM和RAM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RAM是易失性存储器，ROM是非易失性存储器<br>RAM和ROM都是采用随机存取的方式进行信息访问<br>RAM是随机存储器<br>ROM是只读存储器 </p>
<p>RAM掉电不会保存数据，而ROM可以在掉电的情况下，依然保存原有的数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/组成原理_ROM/" data-id="cjm8rmk3z0010rguz8xtfyueq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/OOP/" class="article-date">
  <time datetime="2018-09-12T07:08:48.483Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/OOP/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先介绍一些基本概念</p>
<h3 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h3><p>这两个概率是对于成员函数来说的，接口即是“函数声明”，实现即是“函数定义”。接口是公开的，实现是封装的。接口就是可供外部调用的方法，实现就是内部对这些方法的实现。</p>
<p>接口：接口由使用该类的代码需要执行的操作组成<br>实现：实现一般包括该类所需要的数据，实现还包括定义该类需要的但又不供一般性使用的函数<br>定义类的数据成员和定义普通变量有些相似，：一般不能把类成员的初始化作为其定义的一部分</p>
<h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><p>虚函数：即使是空实现，留给子类去覆盖，提供默认的函数实现<br>纯虚函数：只是个接口，留到子类去实现，抽象类不能直接生成对象，例如“动物”</p>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>抽象类abstract class<br>接口interface在C++中用抽象类来实现，在C#和Java中专门用interface来实现</p>
<h4 id="Java中的抽象类和接口"><a href="#Java中的抽象类和接口" class="headerlink" title="Java中的抽象类和接口"></a>Java中的抽象类和接口</h4><p>为什么Java中会专门弄个接口这个概率呢？首先java是不支持多重继承的，一个类只能extends一个抽象类，但是可以implements多个接口。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑。</p>
<p>抽象类和接口主要体现在设计理念上，抽象类体现的是“is a”关系，而接口体现的是“like a”关系</p>
<p>举个例子，实现一个报警门，方法有开、关和报警，为了ISP原则，我们要把开关和报警分开，由于Java不支持多重继承，我们只能是设计两个接口或者一个抽象类一个接口。这两个方案都是可以的，但是后者更能体现报警门是一个带有报警功能的门，而不是一个带有开关和报警的东西。</p>
<p>PS：例子来自网上，用我自己的话说了一遍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Demo_A &#123;</span><br><span class="line">    abstract void method1();    </span><br><span class="line">    abstract void method2();    </span><br><span class="line">    …   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Demo_I &#123; </span><br><span class="line">    void method1();    </span><br><span class="line">    void method2();    </span><br><span class="line">    …    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-中的抽象类和接口"><a href="#C-中的抽象类和接口" class="headerlink" title="C++中的抽象类和接口"></a>C++中的抽象类和接口</h4><p>在面向对象编程中，抽象类是一种只能定义类型，不能生成对象的类，它是对一系列看上去不同，但是本质相同的具体概念的抽象。要实现抽象类则需要通过纯虚函数实现。</p>
<p>C++的接口是一种特殊的抽象类，需要满足： </p>
<ul>
<li>类中没有定义任何成员变量 </li>
<li>类中所有成员函数都是公有且都是纯虚函数<br>所以，也有用“纯抽象类”这个词来表示接口</li>
</ul>
<p>C++之父还抱怨过为什么这么简单的差别有的人不理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/OOP/" data-id="cjm8rmk3n000lrguzbcocnmvv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learnDB_index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/learnDB_index/" class="article-date">
  <time datetime="2018-09-12T02:10:23.910Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/learnDB_index/">数据库的学习之索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><p>索引是一种特殊的数据库结构，可以用来快速查询数据库表中的特定记录<br>是存储引擎用于快速找到记录的一种数据结构<br>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针</p>
<h4 id="索引的位置"><a href="#索引的位置" class="headerlink" title="索引的位置"></a>索引的位置</h4><p>索引存储在硬盘中的，MYSQL需要的时侯调入部分内容到内存</p>
<p>在内存里，索引肯定是以BST，Trie，Hashtable等形式存在，便于查找。在磁盘上的存储呢？<br>1）不要想到树的序列化问题，不一样，第一，索引是先在磁盘后load到内存里，第二，树的序列化是说要完全保存树的结构，这里不需要，只需要是一颗平衡树就行。<br>2）其实就是一个symbol table，词典，key-value 表，在磁盘上时候不需要有序，只要相关数据保存到了就可以了，load的过程就是给定一个词典建一棵Trie树的问题。只需要从一棵空trie开始，(key,value)做一个结点，不断插入入到Trie里（或者 BST ，hash table）。<br>3）MDS对索引的存储是用xml 把trie的结构也保存了下来，不是为了存储这个树结构本身，而是为了利用Trie的特点，相同前缀只出现一次，公共前缀多的情况下节省存储。当然xml又有overhead，未必真的能节省，但思路是这样。在磁盘上保存树的结构，并不能加速load。</p>
<p>360二面的时候问我索引是在磁盘上还是内存中</p>
<h3 id="应该-不应该建立索引"><a href="#应该-不应该建立索引" class="headerlink" title="应该/不应该建立索引"></a>应该/不应该建立索引</h3><h4 id="应该建立索引"><a href="#应该建立索引" class="headerlink" title="应该建立索引"></a>应该建立索引</h4><ul>
<li>表的主键、外键必须有索引；</li>
<li>数据量超过300的表应该有索引；</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li>
<li>为常作为查询条件的字段建立索引，经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>索引应该建在选择性高的字段上；</li>
<li>为经常需要排序、分组和联合操作的字段建立索引 </li>
</ul>
<h4 id="不应该建立索引"><a href="#不应该建立索引" class="headerlink" title="不应该建立索引"></a>不应该建立索引</h4><ul>
<li><p>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求</p>
</li>
<li><p>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度</p>
</li>
<li><p>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少</p>
</li>
<li><p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当对修改性能的要求远远大于检索性能时，不应该创建索引</p>
</li>
</ul>
<h3 id="？？"><a href="#？？" class="headerlink" title="？？"></a>？？</h3><h4 id="怎么设计索引"><a href="#怎么设计索引" class="headerlink" title="怎么设计索引"></a>怎么设计索引</h4><ul>
<li><p>尽量使用数据量少的索引。尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。 这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了 </p>
</li>
<li><p>尽量使用前缀来索引 </p>
</li>
<li><p>选择惟一性索引</p>
</li>
<li><p>限制索引的数目：索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率， 因为 insert 或 update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要</p>
</li>
<li><p>删除不再使用或者很少使用的索引</p>
</li>
</ul>
<h4 id="怎么使用索引"><a href="#怎么使用索引" class="headerlink" title="怎么使用索引"></a>怎么使用索引</h4><ul>
<li><p>避免对索引字段进行计算操作；</p>
</li>
<li><p>避免在索引字段上使用not、&lt;&gt;、!=：可能导致不走索引，也可能走 INDEX FAST FULL SCAN<br>例如select id  from test where id&lt;&gt;100 </p>
</li>
<li><p>避免在索引字段单使用 IS NULL、IS NOT NULL；</p>
</li>
<li><p>避免在索引字段单出现数据类型转换：索引不适用于隐式转换的情况，比如你的SELECT <em> FROM T WHERE Y = 5 在Y上面有一个索引，但是Y列是VARCHAR2的，那么Oracle会将上面的5进行一个隐式的转换，SELECT </em> FROM T WHERE TO_NUMBER(Y) = 5,这个时候也是有可能用不到索引的</p>
</li>
<li><p>避免在索引字段上使用函数：如果在T表上有一个索引Y，但是你的查询语句是这样子SELECT * FROM T WHERE FUN(Y) = XXX。这个时候索引也不会被用到，因为你要查询的列中所有的行都需要被计算一遍，因此，如果要让这种sql语句的效率提高的话，在这个表上建立一个基于函数的索引，比如CREATE INDEX IDX FUNT ON T(FUN(Y));这种方式，等于Oracle会建立一个存储所有函数计算结果的值，再进行查询的时候就不需要进行计算了，因为很多函数存在不同返回值，因此必须标明这个函数是有固定返回值的</p>
</li>
</ul>
<ul>
<li>避免建立索引的列中使用空值：单键值的B树索引列上存在null值，导致COUNT(<em>)不能走索引。<br>如果在B树索引中有一个空值，那么查询诸如SELECT COUNT(</em>) FROM T 的时候，因为HASHSET中不能存储空值的，所以优化器不会走索引，有两种方式可以让索引有效，一种是SELECT COUNT(*) FROM T WHERE XXX IS NOT NULL或者把这个列的属性改为not null (不能为空)</li>
</ul>
<p>以上情况发生时不会使用索引。除此之外，还有</p>
<p>如果MySQL估计使用索引比全表扫描更慢，则不适用索引，<br>ex：列key_part1均匀的分布在1-100之间。下面的sql则不会使用索引<br>select * from table_name where key_part1 &gt; 1 and key_part1 &lt;90</p>
<p>用or分割开的条件，如果or左右两个条件中有一个列没有索引，则不会使用索引。<br>ex：select * from table_name where key1=’a’ or key2=’b’；<br>如果在key1上有索引而在key2上没有索引，则该查询也不会走索引</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/learnDB_index/" data-id="cjm8rmk3v000urguztnf6bfqs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPPGram_var" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/CPPGram_var/" class="article-date">
  <time datetime="2018-09-12T01:43:50.123Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/CPPGram_var/">C++常见问题之全局/局部/静态变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="全局变量和静态全局变量"><a href="#全局变量和静态全局变量" class="headerlink" title="全局变量和静态全局变量"></a>全局变量和静态全局变量</h4><p>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误</p>
<p>静态全局变量只初使化一次，防止在其他文件单元中被引用; 　　</p>
<p>静态局部变量只被初始化一次，下一次依据上一次结果值； 　　</p>
<p>静态函数与普通函数有什么区别：<br>静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>
<p>静态函数与普通函数作用域不同，仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 </p>
<h4 id="全局变量和静态局部变量"><a href="#全局变量和静态局部变量" class="headerlink" title="全局变量和静态局部变量"></a>全局变量和静态局部变量</h4><p>(1)静态局部变量在函数内定义，但不象自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。 　　<br>(2)静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</p>
<p>全局变量和静态局部变量除了可见区域不同还有什么不同？<br>好像没什么区别了</p>
<p>当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用（尤其是短名全局变量的变量名污染很严重），因此仍以采用局部静态变量为宜</p>
<h3 id="相互联系"><a href="#相互联系" class="headerlink" title="相互联系"></a>相互联系</h3><p>若全局变量仅在单个文件中访问，则可以讲这个变量修改为静态全局变量。<br>若全局变量仅在单个函数中使用，则可以将这个变量修改为该函数的静态局部变量。</p>
<h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>对基本类型的全局变量、静态全局变量和静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/CPPGram_var/" data-id="cjm8rmk36000arguz37hde5o2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/27/Golang_GC/">学习Golang之GC</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_practice/">学习Golang之实战</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Redis4/">Redis之事务</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_defer/">学习Golang之defer</a>
          </li>
        
          <li>
            <a href="/2018/09/25/Redis3/">Redis之应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>