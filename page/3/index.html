<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-learnDB3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/learnDB3/" class="article-date">
  <time datetime="2018-08-18T08:08:02.275Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/learnDB3/">数据库的学习之非关系数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关系型数据库：MySQL，SQL-Server，Oracle"><a href="#关系型数据库：MySQL，SQL-Server，Oracle" class="headerlink" title="关系型数据库：MySQL，SQL Server，Oracle"></a>关系型数据库：MySQL，SQL Server，Oracle</h1><h1 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h1><ul>
<li>文档型数据库：MongoDB、CouchDB、CouchBase、MarkLogic、Clusterpoint</li>
<li>键值存储数据库：Dynamo、FoundationDB、MemcacheDB、Redis、Riak、Aerospike</li>
<li>图数据库：Neo4j、OrientDB、ArangoDB、MapGraph，适合社会关系，公共交通网络，地图及网络拓谱</li>
<li>列式数据库：Cassandra、HBase、Accumulo、Druid、Vertica</li>
<li>内存数据库：Redis、Membase，适合于数据变化快且数据库大小可遇见(适合内存容量)的应用程序</li>
</ul>
<h1 id="关系型和非关系型的区别"><a href="#关系型和非关系型的区别" class="headerlink" title="关系型和非关系型的区别"></a>关系型和非关系型的区别</h1><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>关系型数据库是表格式的，因此存储在表的行和列中，</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/18/learnDB3/" data-id="cjljcxhq1000s1guz7ty3av8s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blockchain2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/blockchain2/" class="article-date">
  <time datetime="2018-08-18T05:04:12.385Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/blockchain2/">自己动手区块链之持久化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上一篇文章，我们实现了一个有POW的单节点区块链。由于没有用到数据库，而是在每次运行程序时，简单地将区块链存储在内存中。那么一旦程序退出，所有的内容就都消失了。我们没有办法再次使用这条链，也没有办法与其他人共享，所以我们需要一个数据库把它存储到磁盘上。</p>
<p>不必使用MySQL这样的数据库，。。。</p>
<p>为了简单考虑，我们会将整个区块链存储为单个文件。我们将使用两种键值对：</p>
<ol>
<li>32 字节的 block-hash -&gt; block 结构</li>
<li>l -&gt; 链中最后一个块的 hash</li>
</ol>
<p>redis里的数据就像这样<br><img src="images/blockchain2.bmp" alt="redis数据格式"></p>
<p>这样，我们在运行我们的区块链时，首先去数据库里检查存储了一个区块链，如果没有区块链</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/18/blockchain2/" data-id="cjljcxhpp000h1guzvverddj6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blockchain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/blockchain/" class="article-date">
  <time datetime="2018-08-18T04:58:38.476Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/blockchain/">自己动手区块链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接触区块链已经有一段时间了，已经学习了比特币、区块链和以太坊这些概念，也用了solidity和truffle这些智能合约工具，自己也思考过区块链的影响与落地。但是区块链的底层技术，只是有基本的认识，没有完全的掌握。希望随着项目的不断进行，可以把区块链的相关技术好好地了解一番。</p>
<p>本人的区块链代码放在Github上，欢迎大家指点</p>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。区块由区块头和区块主体组成，很像TCP/IP协议里那些报文结构。借用网上的一张图<br><img src="images/blockchain3.bmp" alt="区块"><br>区块头</p>
<ul>
<li><p>版本号（version）：用来标识交易版本和所参照的规则。</p>
</li>
<li><p>时间戳（Time）：记录生成这个区块的时间，精确到秒。每诞生一个新的区块，就会被盖上相应的时间戳，这样就保证整条链上的区块都按照时间顺序进行排列。</p>
</li>
<li><p>区块高度和哈希：区块高度是区块的标示符，是指该区块在区块链中的位置。区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。<br><strong>Note：我发现某些实现区块链的项目省略了区块高度这一字段，但其实它是很关键的标识符，在比特币分叉中，人们会提前说明将在比特币高度多少时进行分叉。</strong></p>
</li>
<li><p>哈希：哈希分为“前一区块哈希”和“默克尔根”。“前一区块哈希”通过对前一个区块的区块头数据进行哈希计算（SHA256算法）得出，区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值，保证区块链不被篡改。“默克尔根”通过对当前区块的默克尔树进行哈希计算得出，保证区块数据/交易不被篡改。</p>
</li>
<li><p>难度值：区块难度是用来衡量挖出一个区块平均所需要的运算次数，反映了在一定难度下用多长时间才能挖到一定数量的区块，也是矿工挖矿时重要的参考指标。数据区块产生的难易程度是由难度值（difficulty）来衡量的，我们也可以将difficulty简单的理解为挖到数据区块所用的时间。难度值是要随着算力具体调整的，在我们的项目里，设为固定值</p>
</li>
<li><p>计数器（Nonce）：每人知道符合难度值的哈希值是什么，只能设置一个不断增加的计数器来不断地尝试</p>
</li>
</ul>
<p>区块体：<br>暂略</p>
<p>可以只看自己感兴趣的，或者回过头再来看。</p>
<h3 id="我的区块"><a href="#我的区块" class="headerlink" title="我的区块"></a>我的区块</h3><p>区块是区块链的基本单位，目前我的区块中定义了如下字段：</p>
<ul>
<li>区块高度，</li>
<li>时间戳，</li>
<li>数据，</li>
<li>哈希，</li>
<li>上一个区块的哈希</li>
<li>挖矿的难度值，</li>
<li>计数器，</li>
</ul>
<p>我的破产版区块就长这样</p>
<p><img src="images/blockchain.bmp" alt="区块"></p>
<p>在我的区块中，将交易简化为了数据，将上一个区块的哈希直接放入本区块，本区块的哈希通过计算其他字段获得。相比较真正的区块链，实现难度大大下降。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/18/blockchain/" data-id="cjljcxhpn000f1guzq5qs9sth" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learnGo2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/learnGo2/" class="article-date">
  <time datetime="2018-08-18T01:44:07.592Z" itemprop="datePublished">2018-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/18/learnGo2/">学习Golang之Redis的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Go用到的键值数据库"><a href="#Go用到的键值数据库" class="headerlink" title="Go用到的键值数据库"></a>Go用到的键值数据库</h3><p>现在在项目中使用键值储存（Key-Value-Stores）已经成为了开发者的标配。在Golang中，bolt是一个完全用Go实现一个低级别的键/值存储；而今天的主题是Redis</p>
<h3 id="Go操作Redis的包"><a href="#Go操作Redis的包" class="headerlink" title="Go操作Redis的包"></a>Go操作Redis的包</h3><p>go get github.com/alphazero/Go-Redis</p>
<p>go get github.com/simonz05/godis</p>
<p>redigo听起来挺像“ready？go！”，哈哈哈，redigo更像一个client，执行各种操作都是通过Do函数去做的，它也是官方推荐的<br>    <a href="https://github.com/garyburd/redigo" target="_blank" rel="noopener">github地址</a><br>    <a href="http://godoc.org/github.com/garyburd/redigo/redis" target="_blank" rel="noopener">文档地址</a><br>    获取：<code>$ go get github.com/garyburd/redigo/redis</code></p>
<p>go get github.com/gosexy/redis<br>go get cgl.tideland.biz/redis</p>
<p><a href="https://github.com/go-redis/redis" target="_blank" rel="noopener">github地址</a><br><a href="https://godoc.org/github.com/go-redis/redis" target="_blank" rel="noopener">文档地址</a><br>获取：<code>go get -u github.com/go-redis/redis</code></p>
<h3 id="redigo的介绍"><a href="#redigo的介绍" class="headerlink" title="redigo的介绍"></a>redigo的介绍</h3><h4 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h4><p>连接：Conn接口是使用Redis时主要的接口。应用通过调用Dial，DIalWithTimeout或者NewConn函数来创建连接<br>当使用完连接后务必调用连接Close函数来关闭<br>执行命令：Conn接口有一个执行Redis命令的通用方法，最常用的就是Do方法</p>
<h4 id="String-操作"><a href="#String-操作" class="headerlink" title="String 操作"></a>String 操作</h4><h3 id="go-redis的介绍"><a href="#go-redis的介绍" class="headerlink" title="go-redis的介绍"></a>go-redis的介绍</h3><p>go-redis没有实际用过，这里简单介绍一下。</p>
<h4 id="创建客户端-1"><a href="#创建客户端-1" class="headerlink" title="创建客户端"></a>创建客户端</h4><p>通过 redis.NewClient 函数即可创建一个 redis 客户端, 这个方法接收一个 redis.Options 对象参数, 通过这个参数, 我们可以配置 redis 相关的属性, 例如 redis 服务器地址, 数据库名, 数据库密码等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redisdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">    Addr:     &quot;localhost:6379&quot;,</span><br><span class="line">    Password: &quot;&quot;, // no password set</span><br><span class="line">    DB:       0,  // use default DB</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pong, err := redisdb.Ping().Result()</span><br><span class="line">fmt.Println(pong, err)</span><br></pre></td></tr></table></figure></p>
<p>通过 redisdb.Ping() 来检查是否成功连接到了 redis 服务器</p>
<h4 id="String-操作-1"><a href="#String-操作-1" class="headerlink" title="String 操作"></a>String 操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 第三个参数是过期时间, 如果是0, 则表示没有过期时间.</span><br><span class="line">err := redisdb.Set(&quot;key&quot;, &quot;value&quot;, 0).Err()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val, err := redisdb.Get(&quot;key&quot;).Result()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;key:&quot;, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这里设置过期时间.</span><br><span class="line">err = redisdb.Set(&quot;age&quot;, &quot;20&quot;, 1 * time.Second).Err()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redisdb.Incr(&quot;age&quot;) // 自增</span><br><span class="line">redisdb.Incr(&quot;age&quot;) // 自增</span><br><span class="line">redisdb.Decr(&quot;age&quot;) // 自减</span><br><span class="line"></span><br><span class="line">val, err = redisdb.Get(&quot;age&quot;).Result()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    panic(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;age&quot;, val) // age 的值为21</span><br><span class="line"></span><br><span class="line">// 因为 key &quot;age&quot; 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了.</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">val, err = redisdb.Get(&quot;age&quot;).Result()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // 因为 key &quot;age&quot; 已经过期了, 因此会有一个 redis: nil 的错误.</span><br><span class="line">    fmt.Printf(&quot;error: %v\n&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;age&quot;, val)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/18/learnGo2/" data-id="cjljcxhq6000y1guzyv5r1qsw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learnDB4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/learnDB4/" class="article-date">
  <time datetime="2018-08-17T13:01:53.013Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/17/learnDB4/">数据库的学习之Redis入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在不会Redis简直不敢和人打招呼。Redis以其性能和并发著称。所以用它做缓存实在是再好不过。为什么Redis那么快？</p>
<ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞I/O多路复用机制</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Redis 没有官方的Windows版本，但是微软开源技术团队（Microsoft Open Tech group）开发和维护着这个 Win64 的<a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">版本</a><br>安装完成之后，目录下会有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── redis.windows.conf</span><br><span class="line">├── redis-benchmark.exe</span><br><span class="line">├── redis-check-aof.exe</span><br><span class="line">├── redis-cli.exe</span><br><span class="line">├── redis-server.exe</span><br><span class="line">└── Windows Service Documentation.docx</span><br></pre></td></tr></table></figure>
<p>redis-server.exe是服务器，用来启动redis<br>redis-cli.exe是客户端，命令行工具<br>redis-benchmark.exe是基准测试工具<br>redis-check-aof.exe是AOF持久化文件检测工具和修复工具<br>redis-check-dump是RDB持久化文件检测工具和修复工具</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完成之后，编辑redis.windows.conf文件，</p>
<h1 id="启动客户端和服务器"><a href="#启动客户端和服务器" class="headerlink" title="启动客户端和服务器"></a>启动客户端和服务器</h1><p>和MySQL一样，Git bash也是不支持redis的命令的，我们可以使用cmd或者powershell。<strong>！！！注意</strong> 在没有添加环境变量时，cmd下可以直接从当前位置（C:\redis）加载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ajini&gt;redis-cli</span><br><span class="line">&apos;redis-cli&apos; 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br><span class="line"></span><br><span class="line">C:\Users\ajini&gt;cd C:\redis</span><br><span class="line"></span><br><span class="line">C:\redis&gt;redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<p>但powershell不可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS C:\redis&gt; redis-cli</span><br><span class="line">redis-cli : 无法将“redis-cli”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正</span><br><span class="line">确，然后再试一次。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ redis-cli</span><br><span class="line">+ ~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (redis-cli:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Suggestion [3,General]: 找不到命令 redis-cli，但它确实存在于当前位置。默认情况下，Windows PowerShell 不会从当前位置加载命令。如</span><br><span class="line">果信任此命令，请改为键入“.\redis-cli”。有关详细信息，请参阅 &quot;get-help about_Command_Precedence&quot;。</span><br><span class="line">PS C:\redis&gt; .\redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<p>所以为了方便，我们添加环境变量，以后就可以正常执行Redis的相关命令了。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>执行<code>$ redis-cli -h {host} -p {port}</code>可以让我们以交互方式连接服务器，当然，你也可以选择<code>$ redis-cli -h {host} -p {port} {command}</code>命令方式直接得到服务器的返回结果</p>
<p>如果配置的时候设置了密码，则按照下面的方式登陆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\redis&gt; redis-cli</span><br><span class="line">127.0.0.1:6379&gt; get test</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get test</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="为Redis注册"><a href="#为Redis注册" class="headerlink" title="为Redis注册"></a>为Redis注册</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\redis&gt; redis-server --service-install redis.windows.conf</span><br><span class="line">[15220] 18 Aug 09:27:37.402 # Granting read/write access to &apos;NT AUTHORITY\NetworkService&apos; on: &quot;C:\redis&quot; &quot;C:\redis\&quot;</span><br><span class="line">[15220] 18 Aug 09:27:37.403 # Redis successfully installed as a service.</span><br><span class="line"></span><br><span class="line">PS C:\redis&gt; redis-server.exe --service-start redis.windows.conf</span><br><span class="line">[26364] 18 Aug 09:34:55.243 # Redis service successfully started.</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/17/learnDB4/" data-id="cjljcxhq2000t1guzxia6p2wp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Net_control" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/Net_control/" class="article-date">
  <time datetime="2018-08-17T10:52:28.134Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/17/Net_control/">计算机网络复习之流量控制拥塞控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h3><p>尽管流量控制和拥塞控制采取的动作非常相似（对发送方的遏制），</p>
<p>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制</p>
<ul>
<li>流量控制：控制连接的两端发送数据不要太快；</li>
<li>拥塞控制：控制连接所经过的路由器别超负荷；</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>防止发送节点淹没另一端的接收节点，以消除发送方使接收方缓存溢出的可能性，流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配</p>
<h4 id="流量控制方法"><a href="#流量控制方法" class="headerlink" title="流量控制方法"></a>流量控制方法</h4><p>TCP通过让发送方维护一个称为接收窗口（receive window）的变量来提供流量控制。接收窗口用于告诉发送方，该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口</p>
<p>打开关闭窗口<br>窗口收缩<br>窗口关闭<br>糊涂窗口综合征 </p>
<p>对端用ACK告知窗口大小。本端传递的数据量小于窗口大小。（更好的说法是告诉对端本地的窗口的大小，对端传递的数据量必须小于该窗口）</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>像可靠数据传输一样，拥塞控制也是十分重要且基础的问题。<br>拥塞控制是网络层和传输层的共同责任</p>
<h4 id="拥塞发生原因"><a href="#拥塞发生原因" class="headerlink" title="拥塞发生原因"></a>拥塞发生原因</h4><p>情况1：两个发送方和一台具有无穷大缓存的路由器<br>这种情况下接收方的吞吐量等于发送方的发送速率，吞吐量上限是由两个连接之间对链路容量的共享造成的</p>
<p>最初的延迟是固定的，表示穿过整个网络的传播延迟。随着发送速率接近链路容量，延迟逐步上升，然后骤然上升，超过后源与目的地的平均时延也会变成无穷大</p>
<p>情况2：两个发送方和一台具有有限缓存的路由精<br>这种情况下，当分组到达一个已满的缓存时会被丢弃，同时假定每个连接都是可靠的，所以它终将被发送方重传。由于分组可以被重传，所以我们把应用程序将初始数据发送到套接字中的速率称为发送速率，运输层向网络中发送报文段（含有初始数据和重传数据）速率称为提交负载/供给载荷（offered load）</p>
<p>当发送方仅当确定一个分组已经丢失时才重传，</p>
<p>情况 3: 四个发送方和具在有限援存的多台路由器及多跳路径<br>当提交负载较小时，；当提交负载较大时，在极限情况下，吞吐量趋近于0</p>
<h4 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h4><ul>
<li><p>端到端拥塞控制</p>
<ul>
<li>TCP拥塞控制算法（TCP congestion control algorithm）包括三个主要部分：1. 加法递增乘法递减法则（AIMD, Additive Increase Multiplicative Decrease）；2. 慢启动；3. 对超时事件作出反应</li>
</ul>
</li>
</ul>
<ul>
<li>网络辅助的拥塞控制</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/17/Net_control/" data-id="cjljcxhpj000b1guzngsovu7u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Net_service" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/Net_service/" class="article-date">
  <time datetime="2018-08-17T08:51:18.860Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先，要明确，并非在一个层内完成的全部功能都称为服务。只有哪些能够被高一层实体“看得见”的功能才能称之为“服务”。不同层提供的既有相同的服务，也有不同的服务。<br>后两篇博客将详述流量控制和拥塞控制</p>
<h3 id="面向连接服务与无连接服务"><a href="#面向连接服务与无连接服务" class="headerlink" title="面向连接服务与无连接服务"></a>面向连接服务与无连接服务</h3><p>面向连接的服务按电话系统建模；无连接服务按邮政系统建模</p>
<p>面向连接有三个阶段：连接建立，数据传输和连接释放；无连接没有</p>
<h3 id="面向消息和面向流"><a href="#面向消息和面向流" class="headerlink" title="面向消息和面向流"></a>面向消息和面向流</h3><p>不保留消息边界的协议通常称作“基于流的协议”</p>
<h3 id="可靠服务和不可靠服务"><a href="#可靠服务和不可靠服务" class="headerlink" title="可靠服务和不可靠服务"></a>可靠服务和不可靠服务</h3><p>现实世界中很多的信道是不可靠的，传输过程中，可能会发生位的错误（由0变为1，或者相反），丢包（例如路由器的缓存溢出），到达的包乱序等等，我们将可靠定义为不错，不丢，不乱。</p>
<h4 id="链路层的可靠性"><a href="#链路层的可靠性" class="headerlink" title="链路层的可靠性"></a>链路层的可靠性</h4><p>当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据损<br>链路层可靠交付服务通常用于易于产生高差错率的链路，例如无线链路，其目的是本地(也就是在差错发生的链路上)纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。 然而，对于低比特差错的链路， 包括光纤、同轴电缆和许多双绞铜线链路，链路层可靠交付可能会被认为是一种不必要的开销。 由于这个原因，许多有线的链路层协议不提供可靠交付服务</p>
<h4 id="TCP的可靠性"><a href="#TCP的可靠性" class="headerlink" title="TCP的可靠性"></a>TCP的可靠性</h4><p>TCP通过序列号、检验和、确认应答信号、（超时）重传机制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性</p>
<ul>
<li>序列号：是指按照顺序给发送数据包中的每一个字节都标识上一个编号，接收端主机根据接收数据TCP包首部中的序列号和数据长度，来将自己下一步应该接收的序列号作为确认应答返送回去<ul>
<li>发现丢包</li>
<li>重新排序，保证顺序</li>
<li>丢弃重复数据</li>
<li>提高效率，可实现多次发送，一次确认<br>确认应答处理、重发控制以及重复处理等功能都可以通过序列号来实现</li>
</ul>
</li>
</ul>
<ul>
<li>（超时）重传机制：当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传。TCP含有用于动态估算客户和服务器之间的往返时间RTT的算法，以便它知道等待一个确认需要多少时间<br>报文段发出到收到应答中间有一个报文段的往返时间RTT，显然超时重传时间RTO会略大于这个RTT，TCP会根据网络情况动态的计算RTT，即RTO是不断变化的。<ul>
<li>在Linux中，超时以500ms为单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。其规律为：如果重发一次仍得不到应答，就等待2<em>500ms后再进行重传，如果仍然得不到应答就等待4</em>500ms后重传，依次类推，以指数形式递增，重传次数累计到一定次数后，TCP认为网络或对端主机出现异常，就会强行关闭连接</li>
<li>在Windows系统中，超时时间都是以0.5s 为单位进行控制的，因此超时时间都是0.5s 的整数倍。不过由于最初的数据包还不知道往返时间，所以最初的重发超时时间一般设置为6s 左右</li>
</ul>
</li>
</ul>
<ul>
<li>流量控制，从而确保发送端发送的数据不会使接收缓冲区溢出：总是告知对端在任何时刻它一次能够从对端接收多少字节的数据，这称为通告窗口</li>
</ul>
<h3 id="有应答服务和无应答服务"><a href="#有应答服务和无应答服务" class="headerlink" title="有应答服务和无应答服务"></a>有应答服务和无应答服务</h3><h3 id="流量控制与拥塞控制"><a href="#流量控制与拥塞控制" class="headerlink" title="流量控制与拥塞控制"></a>流量控制与拥塞控制</h3><p>流量控制，flow-control-service</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/17/Net_service/" data-id="cjljcxhpd00081guzrbxjlus7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS_MMU" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/14/OS_MMU/" class="article-date">
  <time datetime="2018-08-14T02:56:20.871Z" itemprop="datePublished">2018-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/OS_MMU/">CPU和MMU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在说中央处理器CPU之前，先要了解计算机存储介质的构成。位于CPU内部的存储介质只有寄存器（CPU内有个寄存器堆，寄存器数量不多，也就20来个），寄存器是容量最小的存储介质，但是是最快的。其他的存储介质都位于CPU外部，容量由小到大分别是cache-&gt;内存-&gt;硬盘-&gt;网络（可视为无限容量）。<br>在我们运行.out文件中的一条指令时，该指令会在CPU中经历如下步骤：</p>
<ol>
<li>由于.out文件保存在磁盘内，由磁盘写入内存，再由内存进入cache区，CPU中的预取器，执行预取指令的工作，把这条二进制形式的指令取进CPU；</li>
<li>预取器把取到的指令交给译码器，译码器对指令进行分析，获知指令要做的工作，以及完成指令需要使用什么寄存器（如果该指令是完成加法操作，就事先取出eax和ebx寄存器，把加数和被加数放在里面备好）；</li>
<li>译码器了解具体的运算类型并且准备好寄存器后，有ALU算术逻辑单元完成具体的运算（算逻单元只会+和&lt;&lt;运算，所有运算都可以通过这两个基本运算完成）；</li>
<li>ALU把计算好的结果回写到相应的寄存器，随后再由cache把哪个记录计算结果的寄存器中的内容取走。</li>
</ol>
<p>CPU中还有一块十分重要的单元——MMU内存管理单元。<br>MMU的作用：</p>
<ol>
<li>虚拟内存与物理内存的映射；</li>
<li>设置和修改内存访问级别。<br>无论我们通过执行一个文件或者系统调用fork()函数产生一个进程，都会产生一片虚拟内存，在32位的系统上，虚拟内存是4G大小（其中0到3G是用户空间可使用的地址，3G到4G是内核空间可以使用的地址）。但是这片内存是虚拟的，并非实际存在的，切实存在的是我们的物理内存，只是我们通过这4G的虚拟内存能够更方便地管理内存空间。由于这块内存是虚拟的，看起来我们的程序相关内容都是存放在这片空间（程序中我们用户所有可以操控的内存地址都是虚拟内存的地址），但是实际还是存放在物理内存上，所以我们就要使用一个方法去把虚拟内存和物理内存之间相互映射，MMU就帮我们完成了这样的映射。在MMU把虚拟内存映射为物理内存的过程中，映射的最小单位是4K 大小（一个Page）,即便虚拟内存有一段区域只有1K大小，在把这块区域映射进物理内存，在物理内存上为它划分空间是时，也会毫不犹豫地划分出4K大小的区域。<br>MMU在完成映射的同时，还为CPU设置了对物理内存的访问级别。简单地说，访问级别最高是Ring0，是内核空间Kernel Space；最低是Ring3，是用户空间User Space。<br>例如：在程序执行一条命令printf()打印输出一些内容到屏幕上，调用printf()阶段，CPU运行在用户空间，但是printf()还需要向下作系统调用write()，此时CPU进入内核空间，对内存的访问级别发生了改变（由Ring3-&gt;Ring0）,这种级别的调整，就是MMU帮助CPU完成的。<br>MMU的工作在程序运行起来的时候就开始了，因为从cache上面取来的指令中使用的变量，数值等对应的存储位置就是虚拟内存，MMU需要把它映射到物理内存上，才能真正取出变量中的值。同样的CPU计算完把结果返回给cache也需要MMU协助把物理内存映射回虚拟内存。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/14/OS_MMU/" data-id="cjljcxhpg00091guzf1f6mysi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Developer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/12/Developer/" class="article-date">
  <time datetime="2018-08-12T12:36:16.840Z" itemprop="datePublished">2018-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/Developer/">开发者的战争之语言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为一个开发者，他在开发的过程中会用到各种各样的工具，各种各样的语言，各种各样的系统等等。其中的每一个话题都会在论坛引起相关的讨论。不同的开发者会有不同的偏好，这给程序员社区带来了不少有趣的论战。我把这些主题的博客称为“开发者的战争”，因为很多时候的讨论真的有点类似宗教之间的圣战。</p>
<h3 id="开发者战争之编辑器"><a href="#开发者战争之编辑器" class="headerlink" title="开发者战争之编辑器"></a>开发者战争之编辑器</h3><p>任何人从小接触计算机（windows）的时候，一定是从记事本Notepad，画图，扫雷开始的。深入之后会去office三件套word，ppt和excel。在没有编程之前，我一直以为记事本和word没什么区别，只不过记事本更加简陋而已。。。<br>在Liunx下，最著名的编辑器莫过于Vim了。</p>
<p>除了编辑器之外，集成开发环境就没有太多争议了，这是因为有“宇宙第一IDE”之称的Visual Studio, VS，一骑绝尘。 </p>
<h3 id="开发者战争之语言"><a href="#开发者战争之语言" class="headerlink" title="开发者战争之语言"></a>开发者战争之语言</h3><p>如果说编辑器只是微不足道的小不同，那语言绝对是天然的划分属性。每年都会有网站统计最受欢迎的语言排名。例如<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE</a></p>
<p>对于语言之间的不同特性，很多人会用各种各样的比喻和通俗化解释，例如枪械，二次元。详情请见<a href="https://www.zhihu.com/question/25038841" target="_blank" rel="noopener">PHP、Java、Python、C、C++ 这几种编程语言都各有什么特点或优点？</a></p>
<p>每种语言都会有一句自己的口号<br>语言 | Slogan<br>:-: | :-:<br>Ruby | Do one thing more than one way<br>Python | 约定优于配置<br>JavaScript | 凡是能用JavaScript重写的都将会被JavaScript重写<br>Java | 一次编译到处运行<br>Golang | 互联网时代的C语言</p>
<p>如果我们从大的角度划分，语言其实可以分为：</p>
<h4 id="机器汇编和高级"><a href="#机器汇编和高级" class="headerlink" title="机器汇编和高级"></a>机器汇编和高级</h4><p>机器语言，汇编语言和高级语言是按照等级划分的。</p>
<h4 id="编译型和解释型的区别"><a href="#编译型和解释型的区别" class="headerlink" title="编译型和解释型的区别"></a>编译型和解释型的区别</h4><p>个人认为表面的差异，例如python的缩进，golang的错误处理，不是本质的东西。底层的编译原理才是它们的最大差别。</p>
<p>在《编译原理》一开头，语言处理器就划分为两类——编译器和解释器interpreter</p>
<p>源程序–编译器–&gt;目标程序<br>源程序和输入–解释器–&gt;输出</p>
<h4 id="标记、脚本和编程语言"><a href="#标记、脚本和编程语言" class="headerlink" title="标记、脚本和编程语言"></a>标记、脚本和编程语言</h4><ul>
<li>标记语言，是一种将文本（Text）以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。与文本相关的其他信息（包括例如文本的结构和表示信息等）与原来的文本结合在一起，但是使用标记（markup）进行标识。<br>我们常用的XML、JSON、HTML是标记语言，我写这篇博客用的markdown它也是标记语言。</li>
<li>脚本语言是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。它的命名起源于一个脚本“screenplay”，每次运行都会使对话框逐字重复。早期的脚本语言经常被称为批量处理语言或工作控制语言。<br>Python、PHP、Ruby、Lua、JavaScript它们都是脚本语言</li>
<li>编程语言（programming language）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合以上的说明，我们可以把语言划分为<br>编程语言的代际划分也是这样的<br>代 | |类如<br>:-: | :-: | :-:<br>第一代 | 机器语言<br>第二代 | 汇编语言<br>第三代 | 面向过程语言：C、FORTHAN语言<br>第四代 | 面向对象语言：C++（编译型） Java、C#（半编译半解释）<br>第五代 | 脚本语言：Python、PHP、Ruby、Lua、JavaScript<br>第六代 | 专业性的语言：MATLAB精于数值计算，Map适合符号运算，R/sas等适合统计计算</p>
<p>当然语言之间还有其他的一些区别，请见下篇博客“开发者的战争之静态动态问题”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/12/Developer/" data-id="cjlofx6qp00043guzmgsneqcm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS_gdb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/10/OS_gdb/" class="article-date">
  <time datetime="2018-08-10T14:38:30.156Z" itemprop="datePublished">2018-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/10/OS_gdb/">gdb调试的学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>首先调试之前要具备一个包含调试信息的可执行文件：<br>使用gcc    *.c    -o    app    -g命令可以获得（在讲解gcc的文章中有所介绍）。</li>
<li>对该可执行文件app启动gdb调试：<br>使用命令：gdb    app</li>
<li>具体的调试方法：</li>
</ol>
<ul>
<li>gdb中使用l命令可以查看文件：<br><strong>命令l</strong>    文件名：行数（查看指定文件的某行）<br><strong>命令l</strong>    文件名：函数名（查看指定文件的某个函数）<br><strong>命令l</strong>    每点一次l会把文件向后滚动列出10行</li>
<li>执行程序前先设置一般的断点：<br>命令 break    行数（在该行设置一个断点）<br>设置条件断点：<br>命令 b（或者break都可以）    行数    if    条件（在满足这个条件时候才会break停住，常用在for循环中，指定到达某次循环即循环变量i到某个指定值时让程序暂停）<br>查看断点的信息：<br>命令 i（或者info）    b</li>
<li>设置好断点可以开始运行程序，在运行时调试：<br>命令 start（从程序开始向后执行一步）<br>命令 run（直接执行在第一个端点处）<br>命令 n（从当前位置向后执行一步，进行单步调试，在遇到函数时候，不进入函数体内，直接执行下一行）<br>命令 c（从当前位置继续执行，直到遇到条件成熟的断点停下）<br>命令 s（也是单步执行，遇到函数体会进入其中）<br>命令P    变量名（在函数体内调试是可以查看对应变量的值）<br>命令 display    变量名（可以在循环中简单追踪循环变量值的改变，实行追踪时会给这个变量分配一个临时编号，若想要去掉追踪，用命令display    变量编号，就可以除去追踪）<br>命令 u（跳出当前循环，直接跳出当前的for之类的循环向后执行程序）<br>命令 finish（跳出当前函数，但是执行finish之前首先要删掉我们打在函数外面的断点，<br>命令 d   断点编号可以删掉对应编号的断点）<br>命令 set    var    变量名=指定值（直接设置一个变量到达某个值，常让它能够满足某个条件断点的条件时使用）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/10/OS_gdb/" data-id="cjljcxhpl000d1guzdvc455bl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/04/C++1/">C++常见问题之static,violate,const</a>
          </li>
        
          <li>
            <a href="/2018/09/03/CO_32or64/">计算机组成原理之32or64</a>
          </li>
        
          <li>
            <a href="/2018/09/01/datastruct3/">数据结构和算法之海量数据处理</a>
          </li>
        
          <li>
            <a href="/2018/09/01/designpattern2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/29/C++6/">C++常见问题之内存布局（三）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>