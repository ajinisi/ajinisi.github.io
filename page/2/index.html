<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-learnDB_index1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/learnDB_index1/" class="article-date">
  <time datetime="2018-09-18T14:18:32.160Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/18/learnDB_index1/">数据库的学习之索引（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="按照存储方式分类"><a href="#按照存储方式分类" class="headerlink" title="按照存储方式分类"></a>按照存储方式分类</h3><p>聚集索引/聚簇索引 clustered index</p>
<p>二级索引/辅助索引/非聚集索引 secondary indexes </p>
<p>除聚集索引之外的索引</p>
<h4 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h4><ul>
<li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</li>
</ul>
<p>聚集索引:表中存储的数据按照索引的顺序存储,检索效率比普通索引高,但对数据新增/修改/删除的影响比较大<br>非聚集索引:不影响表中的数据存储顺序,检索效率比聚集索引低,对数据新增/修改/删除的影响很少</p>
<ul>
<li>每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。聚集索引插入数据时速度要慢（时间花费在“物理存储的排序”上，也就是首先要找到位置然后插入）查询数据比非聚集数据的速度快，而非聚集索引一个表可以存在多个</li>
</ul>
<h4 id="聚集索引的使用"><a href="#聚集索引的使用" class="headerlink" title="聚集索引的使用"></a>聚集索引的使用</h4><p>如果表上定义有主键，该主键索引就是聚簇索引。<br>如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。<br>如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引</p>
<p>但是我们不应该把主键作为聚集索引，这是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。</p>
<p>　　通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列 Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。</p>
<p>　　显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。</p>
<p>　　从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中， 因为ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪 费。其次，让每个ID号都不同的字段作为聚集索引也不符合大数目的不同值情况下不应建立聚合索引规则；当然，这种情况只是针对用户经常修改记录内容，特别 是索引项的时候会负作用，但对于查询速度并没有影响。</p>
<h3 id="按照维护与管理索引的角度分类"><a href="#按照维护与管理索引的角度分类" class="headerlink" title="按照维护与管理索引的角度分类"></a>按照维护与管理索引的角度分类</h3><p>普通索引：（由关键字KEY或INDEX定义得到索引）：加快数据的查询速度</p>
<p>最常见的索引类型涉及单个列，在数据结构中存储该列的值的副本，允许快速查找具有相应列值的行。B树数据结构可以让索引快速查找特定值，一组值，或值的范围，对应于</p>
<p>唯一索引：由关键字UNIQUE把它定义为唯一索引）：保证数据记录的唯一性<br>复合索引/联合索引/多列索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引</p>
<p>复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：<br>正确选择复合索引中的主列字段，一般是选择性较好的字段；<br>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </p>
<p>主键索引：一种特殊的唯一索引，在一张表中只能定义一个主键索引，用来标识唯一一条数据，用PRIMARY KEY创建。</p>
<p>全文索引 FULLTEXT：是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值</p>
<p>空间数据索引 R-Tree</p>
<h4 id="主键和唯一索引的区别"><a href="#主键和唯一索引的区别" class="headerlink" title="主键和唯一索引的区别"></a>主键和唯一索引的区别</h4><ol>
<li><p>对于主健/unique constraint ， oracle/sql server/mysql等都会自动建立唯一索引；</p>
<p> 在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据</p>
</li>
<li><p>主键不一定只包含一个字段，所以如果你在主键的其中一个字段建唯一索引还是必要的；</p>
</li>
<li>主健可作外健，唯一索引不可；</li>
<li>主健不可为空，有not null属性，唯一索引可以为空；</li>
<li>主健也可是多个字段的组合；</li>
<li>主键每个表只能有一个。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/18/learnDB_index1/" data-id="cjm8rmk3x000xrguzdbd38037" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OOP_cons" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/OOP_cons/" class="article-date">
  <time datetime="2018-09-18T06:56:47.577Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/18/OOP_cons/">面向对象之构造函数析构函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>• 构造函数是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型<br>• 而与其他成员函数相同的是，构造函数也有形参表（可能为空）和 函数体。<br>• 一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参<br>• 构造函数是类的特殊非静态成员函数，用于初始化其类类型的对象<br>• 构造函数无名且不能直接调用。它们在初始化发生时调用，且它们按照初始化的规则选择。<br>    ○ 无 explicit 指定符的构造函数是转换构造函数。<br>    ○ 有 constexpr 指定符的函数令其类型为字面类型 (LiteralType) 。<br>    ○ 可以不带任何参数调用的构造函数是默认构造函数。<br>    ○ 可以接收同类型的另一对象为参数的构造函数是复制构造函数和移动构造函数</p>
<h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p>列表中成员初始化器的顺序是不相关的：初始化的实际顺序如下： </p>
<pre><code>1. 若构造函数是最终导出类的，则按基类声明的深度优先、从左到右遍历顺序（从左到右指的是基指定符列表中的出现）初始化虚基类
2. 然后，以从如它们出现于此类的基指定符列表的左到右顺序初始化直接基类
3. 然后，以类定义中__声明顺序__初始化非静态成员
4. 最后，执行构造函数体
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"> </span><br><span class="line">struct Base &#123;</span><br><span class="line">    int n;</span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line">struct Class : public Base</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char x;</span><br><span class="line">    unsigned char y;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg;</span><br><span class="line">    std::fstream f;</span><br><span class="line">    std::string s;</span><br><span class="line"> </span><br><span class="line">    Class ( int x )</span><br><span class="line">      : Base &#123; 123 &#125;, // 初始化基类</span><br><span class="line">        x ( x ),      // x （成员）以 x （参数）初始化</span><br><span class="line">        y &#123; 0 &#125;,      // y 初始化为 0</span><br><span class="line">        f&#123;&quot;test.cc&quot;, std::ios::app&#125;, // 这在初始化 m 和 lg 后发生</span><br><span class="line">        s(__func__),   //__func__ 可用，因为初始化器列表是构造函数的一部分</span><br><span class="line">        lg ( m ),      // lg 使用已经初始化的 m</span><br><span class="line">        m&#123;&#125;            // m 在 lg 前初始化，即使它在此最后出现</span><br><span class="line">    &#123;&#125;                // 空复合语句</span><br><span class="line"> </span><br><span class="line">    Class ( double a )</span><br><span class="line">      : y ( a+1 ),</span><br><span class="line">        x ( y ), // x 将在 y 前初始化，其值不确定</span><br><span class="line">        lg ( m )</span><br><span class="line">    &#123;&#125; // 基类构造函数不出现于列表，它被默认初始化（与假如使用 Base() 不同，那是值初始化）</span><br><span class="line"> </span><br><span class="line">    Class()</span><br><span class="line">    try // 函数 try 块始于包含初始化器列表的函数体前</span><br><span class="line">      : Class( 0.0 ) // 委托构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化出现异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    Class c;</span><br><span class="line">    Class c1(1);</span><br><span class="line">    Class c2(0.1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数<br>调用顺序</p>
<p>基类构造函数、对象成员构造函数、派生类本身的构造函数  </p>
<p>派生类本身的析构函数、对象成员析构函数、基类析构函数（与构造顺序正好相反）</p>
<p>3、特例<br>局部对象，在退出程序块时析构<br>静态对象，在定义所在文件结束时析构<br>全局对象，在程序结束时析构<br>继承对象，先析构派生类，再析构父类<br>对象成员，先析构类对象，再析构对象成员</p>
<p>下面归纳一下什么时候调用构造函数和析构函数：<br>1) 在全局范围中定义的对象(即在所有函数之外定义的对象)，它的构造函数在文件中的所有函数(包括main函数)执行之前调用。但如果一个程序中有多个文件，而不同的文件中都定义了全局对象，则这些对象的构造函数的执行顺序是不确定的。当main函数执行完毕或调用exit函数时(此时程序终止)，调用析构函数。</p>
<p>2) 如果定义的是局部自动对象(例如在函数中定义对象)，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。</p>
<p>3) 如果在函数中定义静态(static )局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。</p>
<h4 id="为什么构造不能为虚"><a href="#为什么构造不能为虚" class="headerlink" title="为什么构造不能为虚"></a>为什么构造不能为虚</h4><p>第一点，没有意义。虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。虚函数的作用在于通过父类的指针或引用来调用父类或子类的那个成员函数，而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。对象的构造则是由编译器完成的，由于在创建一个对象的过程中，涉及到资源的创建，类型的确定。要创建一个对象，你需要知道对象的完整信息。特别是，你需要知道你想要创建的确切类型。而这些是不能在运行过程中确定的，需要在编译的过程中就确定下来。</p>
<p>第二点，时间上矛盾。虚函数对应一个指向vtable虚函数表的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。所以，这个调用也是违背先实例化后调用的准则</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h4 id="为什么析构函数要虚"><a href="#为什么析构函数要虚" class="headerlink" title="为什么析构函数要虚"></a>为什么析构函数要虚</h4><p>若类为多态（声明或继承至少一个虚函数），且其析构函数非虚，通过指向基类指针删除对象引发未定义行为，无关乎若不调用派生的虚构函数是否导致资源泄漏————实际执行时通常发生的是对象的派生成分没被销毁，于是造成一个诡异的“局部销毁”对象</p>
<p>相反，虽然虚析构函数是不继承的，若基类声明器其析构函数为 virtual ，则导出的析构函数始终覆写它。这使得可以通过指向基类的指针 delete 动态分配的多态类型对象</p>
<p>由于虚函数是释放对象的时候才执行的，所以一开始也就无法确定析够函数的。而去由于析构的过程中，是先析构子类对象，后析构父类对象。所以，需要通过虚函数来指引子类对象。所以，如果不设置成虚函数的话，析构函数是无法执行子类的析构函数的</p>
<p>• 因此，一条有用的方针，是任何基类的虚函数必须为公开且虚，或受保护且非虚<br>    ○ Effective C++: 带有多态性质的基类应该声明一个虚析构函数<br>并非所有基类的设计目的都是为了多态用途，如条款6和条款47，因此他们不需要虚析构函数</p>
<h3 id="构造函数或者析构函数中调用虚函数会怎样"><a href="#构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="构造函数或者析构函数中调用虚函数会怎样"></a>构造函数或者析构函数中调用虚函数会怎样</h3><p>基类的构造函数中又调用了虚函数saleRecord()， 在此，你认为基类构造函数中所调用的虚函数saleRecord的实现版本是哪一个呢，是基类的实现版本还是派生类B的实现版本呢？</p>
<p>详情见《effective C++》第九条款 </p>
<p>也是两点，第一点，在创建派生类的时候，基类先于派生类被构造，编译器或者程序其实目光是很短浅的或者说是很现实的，在调用基类构造函数的时候，它并不知道你最终是要创建一个基类还是派生类，它只要把现在手头上的工作做好——创建一个基类。因此它没有办法调用派生类B的实现版本。</p>
<p>第二点，假设它可以调用派生类B的实现版本。此时，又会发生什么呢。从意图上讲，我们要调用虚函数的不同版本，从根本上讲，是要对不同的数据进行操作，这样函数才有意义。比如说基类的虚函数版本是对基类的数据进行操作， 派生类的虚函数版本是对派生类的数据进行操作。 但此时，派生类的构造函数还没有调用，派生类的数据成员也不会有相应的初始化，这时候对派生类的数据成员操作完全是无意义的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/18/OOP_cons/" data-id="cjm8rmk3q000orguz8jo77f8f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-datastruct_searchtree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/datastruct_searchtree/" class="article-date">
  <time datetime="2018-09-18T03:10:56.993Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/18/datastruct_searchtree/">数据结构和算法之查找树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前言：BST、AVL、RBT、B-tree都是动态结构，查找时间基本都在O(longN)数量级上。下面做出详细对比。</p>
<h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><p>(1) 查找代价：<br>任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。<br>查找最好时间复杂度O(logN)：当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。<br>最坏时间复杂度O(N)：当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)/2，查找的平均时间复杂度在O(N)数量级上。<br>(2) 插入代价：<br>新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。<br>(3) 删除代价：<br>当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的…的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。<br>插入删除操作算法简单，时间复杂度与查找差不多。</p>
<h3 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h3><p>二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。<br>AVL 的操作代价分析：<br>(1) 查找代价：<br>AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。<br>(2) 插入代价：<br>AVL必须要保证严格平衡(|bf|&lt;=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。<br>(3) 删除代价：<br>AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)</p>
<h3 id="RBT"><a href="#RBT" class="headerlink" title="RBT"></a>RBT</h3><p>二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。但是这样做是否值得呢？<br>能不能找一种折中策略，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率呢？ 答案就是：红黑树。<br>RBT 的操作代价分析：<br>(1) 查找代价：<br>由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点，但也远远好于BST。<br>(2) 插入代价：<br>RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。<br>(3) 删除代价：<br>RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</p>
<p>插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。</p>
<h3 id="B-树-B-树-B-Tree"><a href="#B-树-B-树-B-Tree" class="headerlink" title="B~树/B+树 (B-Tree )"></a>B~树/B+树 (B-Tree )</h3><p>对于在内存中的查找结构而言，红黑树的效率已经非常好了(实际上很多实际应用还对RBT进行了优化)。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成RBT结构显然是不实际的。实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储。都不可能在内存中建立查找结构。必须在磁盘中建立好这个结构。那么在这个背景下，RBT还是一种好的选择吗？<br>在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。<br>B-Tree的操作代价分析：<br>(1) 查找代价：<br>B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。<br>(2)插入代价：<br>B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。<br>(3)删除代价：<br>B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）。<br>(4)定义：<br>一颗m阶（m&gt;=3，即一个结点包含的数据和子节点数），3阶B-树有如下特点： </p>
<ol>
<li>根结点之多3颗子树 </li>
<li>定义：<br>define m 3                 /<em>B 树的阶</em>/<br>typedef struct Node{<br> int keynum;             /<em> 结点中关键码的个数，即结点的大小</em>/<br> int key[m];               /<em>结点数据数组</em>/<br> struct Node <em>parent;  /</em>指向父节点的指针<em>/<br> Node</em>son[m];    /<em>指向子结点的指针数组</em>/<br>};<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>B-Tree效率总结：<br>由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。</li>
</ol>
<h3 id="AVL-PK-RBT"><a href="#AVL-PK-RBT" class="headerlink" title="AVL PK RBT"></a>AVL PK RBT</h3><p>AVL 和RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。<br>结构对比： AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL &gt; RBT.<br>查找对比： AVL 查找时间复杂度最好，最坏情况都是O(logN)。RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。<br>插入删除对比： </p>
<ol>
<li>AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。 </li>
<li>如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。 </li>
<li>当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。 </li>
<li>AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。<br>总体评价：大量数据实践证明，RBT的总体统计性能要好于平衡二叉树。</li>
</ol>
<h3 id="B-Tree-PK-B-Tree"><a href="#B-Tree-PK-B-Tree" class="headerlink" title="B-Tree PK B+Tree"></a>B-Tree PK B+Tree</h3><p>B+树是B-树的一种变体，在磁盘查找结构中，B+树更适合文件系统的磁盘存储结构。<br>结构对比：<br>B-树是平衡多路查找树，所有结点中都包含了待查关键字的有效信息(比如文件磁盘指针)。每个结点若有n个关键字，则有n+1个指向其他结点的指针。<br>B+树相比B-树的特点： </p>
<ol>
<li>数据只出现在叶子结点，B-树每个结点都包含了数据； </li>
<li>叶子结点之间用指针连接； </li>
<li>B+树的高度一般是3；<br>查找对比： </li>
<li>在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B-树。由于B+树所在的磁盘存储背景下，因此B+树的查找性能要好于B-树。 </li>
<li>B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。<br>插入删除对比： B+树与B-树在插入删除操作中的效率是差不多的。<br>总体评价：在应用背景下，特别是文件结构存储中。B+树的应用要更多，其效率也要比B-树好。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/18/datastruct_searchtree/" data-id="cjm8rmk3t000rrguzcecm5i89" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-datastruct5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/datastruct5/" class="article-date">
  <time datetime="2018-09-18T01:50:07.445Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/18/datastruct5/">数据结构和算法之STL(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="std-set-lower-bound与std-lower-bound的效率问题"><a href="#std-set-lower-bound与std-lower-bound的效率问题" class="headerlink" title="std::set::lower_bound与std::lower_bound的效率问题"></a>std::set::lower_bound与std::lower_bound的效率问题</h3><p>应该是set&lt;&gt;::iterator不支持随机访问，所以直接当作普通的序列进行二分std::lower_bound的时候就不是O(logn)的复杂度了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/18/datastruct5/" data-id="cjm8rmk3t000srguz3xvv1u86" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NET_comp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/17/NET_comp/" class="article-date">
  <time datetime="2018-09-17T13:59:06.523Z" itemprop="datePublished">2018-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/17/NET_comp/">计算机网络复习之综合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="输入URL后回车"><a href="#输入URL后回车" class="headerlink" title="输入URL后回车"></a>输入URL后回车</h3><p>输入网址，DNS查找：</p>
<ol>
<li>浏览器缓存</li>
<li>系统缓存 </li>
<li>路由器缓存 </li>
<li>ISP的DNS缓存，递归搜索 </li>
</ol>
<p>（1）当用户在浏览器中输入<a href="http://www.qq.com域名访问该网站时，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。" target="_blank" rel="noopener">www.qq.com域名访问该网站时，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a> </p>
<p>（2）如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </p>
<p>（3）如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </p>
<p>（4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 </p>
<p>（5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机。" target="_blank" rel="noopener">www.qq.com主机。</a> </p>
<p>（6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。<br>提示：从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间的交互查询就是迭代查询。</p>
<p>浏览器给web服务器发送HTTP请求</p>
<p>facebook服务的永久重定向响应</p>
<p>浏览器跟踪重定向地址</p>
<p>服务器“处理”请求<br>再服务器发回一个HTML响应</p>
<p>浏览器开始显示HTML<br>再浏览器发送获取嵌入在HTML中的对象</p>
<p>浏览器发送异步（AJAX）请求</p>
<h3 id="ping的过程"><a href="#ping的过程" class="headerlink" title="ping的过程"></a>ping的过程</h3><ol>
<li>PC1在应用层发起个目标IP为192.168.2.2的Ping请求。</li>
<li>传输层接到上层请求的数据，将数据分段并加上UDP报头。下传到Internet层。   </li>
<li>网际层接收来处上层的数据后，根据ICMP协议进行封装，添加PC1的IP为源IP为和PC2IP为目标IP后封装成数据包。下传到网络接口层，因Pc1 ip与pc2 ip不在同一网段，所以数据包将发往网关Router E0口。<br>4、网络接口层接收数据包后，进行封装，源MAC地址为PC1的MAC地址，目标MAC地址则查询自己的ARP缓存表以获取网关MAC地址。如果PC1 arp缓存表中没有网关对应的MAC地址，则PC1发出一个ARP广播报文。ARP报文中源MAC地址为Pc1 mac地址，源IP地址为PC1 IP，所要请求的是网关IP对应的MAC地址<br>5、交换机1从F0/1接收到ARp帧后，检查自己Arp缓存表中是否有与F0/1口相对应PC1的mac地址。没有，则将PC1Mac地址与F0/1接口对应起来，存储到交换机1的arp缓存表中。然后将该ARP请求报文进行除F0/1口以外的所有端口进行泛洪。<br>6、Router收到ARP广播后，进行解封装，发现所要请求的MAC地址是自己的。则Router将PC1的mac地址写入arp缓存表中。然后向PC1发送一个ARP应答单播。该单播消息包括目标IP为PC1ip，目标Mac为pc1mac地址，源IP为Router的E0口IP，源Mac为Router的E0的Mac。<br>7、ARP帧F0/24口传给交换机，交换机同样检查MAC表，然后将F0/24口与Router的E0的MaC地址对应起来，存入MAC缓存表中，然后转发该帧。<br>8、Pc1接收到Router的arp应答帧后，将Router的E0的MAC地址存入arp缓存中，并将Router的E0的Mac地址作为目标地址封装到数据帧中。发给下层进行网络传输。<br>9、Router的E0接收这个帧后，看目标mac地址是否指向自己。是，PC2则将帧头去掉，然后检查目标ip地址，发现这个目标ip不是自己，刚不再进行解封装。<br>10、Router在自己的route表中检查自己的是否有去往目标地址的路由，没有则丢弃该帧。有，路由器经检查发现是去往与E1口直连的网段。则路由器对数据包进行二层封装成帧，源IP为pc1的IP，源mac地址为routerE1口的Mac地址，目标IP为Pc2的ip，目标Mac地址则检查自己的arp缓存表获取。如果没有，则发送ARp请求报文。<br>11、交换机收到报文后也检查ARp缓存表，然后存储对应接口的MAC地址后进行除接收端口外的泛洪。<br>12、PC2收到ARP广播后，进行解封装，发现所请求的MAC地址是自己的。则RouterE1的mac地址写入arp缓存表中。然后向PC1发送一个ARP应答单播。该单播消息包括目标IP为RouterE1的ip，目标Mac为RouterE1的mac地址，源IP为PC2的IP，源Mac为pc2的Mac。<br>13、ARP帧经F0/24口传给交换机，交换机同样检查MAC表，然后将F0/24口与PC2的MaC地址对应起来，存入MAC缓存表中，然后转发该帧。<br>14、RouterE1口接收到PC2的arp应答帧后，将Pc2的MAC地址存入arp缓存中，并将Pc2的Mac地址作为目标地址封装到数据帧中，然后转发。<br>15、Pc2网际层接收到这个信息包，查看包头，发现目标IP和自己匹配，则解封装，将数据向上层传输。<br>16、传输层接收来自下层的Ping请求的UDP报文，则去掉UDP报头，向应用层传送。<br>17、应用层收到ping请求后，发送一个PIng回应报文给PC</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/17/NET_comp/" data-id="cjm8rmk3l000irguzeeuu7qaa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-组成原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/组成原理/" class="article-date">
  <time datetime="2018-09-16T12:04:13.553Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/组成原理/">计算机组成原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="组成原理和体系结构"><a href="#组成原理和体系结构" class="headerlink" title="组成原理和体系结构"></a>组成原理和体系结构</h3><p>1.计算机体系结构Computer Architecture 主要研究硬件和软件功能的划分，确定硬件和软件的界面，即哪些功能应划分给硬件子系统完成，哪些功能应划分到软件子系统中完成．主通常是指涉及机器语言或者汇编语言的程序设计人员所见到的计算机系统的属性，更多说的是计算机的外特性，是硬件子系统的结构概念及其功能特性。</p>
<p>2.计算机组成原理<br>包括计算机系统概论；运算方法和运算器；存储系统；指令系统；中央处理器；总线；外围设备等 。是依据计算机体系结构确定并且分配了硬件子系统的概念结构和功能特性的基础上，设计计算机各部件的具体组成，它们之间的连接关系，实现机器指令级的各种功能和特性。从这一点又可以说，计算机组成是计算机体系结构的逻辑实现。 </p>
<p>微机原理：只是对非计算机专业的学生开的，大部分将8086的结构以及如何工作，还有汇编语言怎麼写。</p>
<p>计算机组成原理：探讨计算机的各个部分怎麼实现（电路）。</p>
<p>计算机体系结构讲的是在计算机组成原理的基础上，如何根据不同的场景和使用情况的设计计算机，以及各种设计的优缺点。</p>
<p>就拿缓存来说，计算机组成原理讲的是缓存怎麼做的（DRAM四个晶体管构成一个单元），而计算机体系结构讲的是缓存在cpu里怎么用（多级缓存，不同级别的缓存采用不同的寻址方式），才可以达到最大性能，不同使用方法的优缺点以及在实际中根据不同情况怎么折衷。</p>
<p>硬盘：在计算机组成原理里讲的硬盘怎么做的，磁头读写的物理机制，而计算机体系结构讲如何设计磁盘排列才能以最低的成本使发生意外数据损失的概率达到要求 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/组成原理/" data-id="cjm8rmk3w000wrguz0ghp6tpi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Web" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/Web/" class="article-date">
  <time datetime="2018-09-16T11:55:35.168Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/Web/">web开发之ajax原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</p>
<ol>
<li>使用CSS和XHTML来表示。</li>
<li>使用DOM模型来交互和动态显示。</li>
<li>使用XMLHttpRequest来和服务器进行异步通信。</li>
<li>使用javascript来绑定和调用。</li>
</ol>
<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/Web/" data-id="cjmkoxr6f000dg4uzaq1mlpjb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OOP_bind" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/OOP_bind/" class="article-date">
  <time datetime="2018-09-16T08:16:26.136Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/OOP_bind/">C++常见问题之绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>绑定：一个方法的调用与方法所在的类关联起来。java中的绑定分为静态绑定和动态绑定，又被称作前期绑定和后期绑定</p>
<p>静态绑定：（final、static、private）在程序执行前已经被绑定，也就是说在编译过程中就已经知道这个方法是哪个类的方法，此时由编译器获取其他连接程序实现。</p>
<p>静态绑定：编译时绑定， 通过对象调用 </p>
<p>动态绑定：在运行根据具体对象的类型进行绑定</p>
<p>动态绑定：运行时绑定，通过地址实现 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/OOP_bind/" data-id="cjm8rmk3m000jrguzy01no07r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NET_address" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/NET_address/" class="article-date">
  <time datetime="2018-09-16T07:52:24.271Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/NET_address/">计算机网络复习之地址</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="IP地址和MAC地址的区别"><a href="#IP地址和MAC地址的区别" class="headerlink" title="IP地址和MAC地址的区别"></a>IP地址和MAC地址的区别</h3><p>1.对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变。</p>
<p>　　2. 长度不同。IP地址为32位，MAC地址为48位。</p>
<p>　　3. 分配依据不同。IP地址的分配是基于网络拓朴，MAC地址的分配是基于制造商。</p>
<p>　　4. 寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。</p>
<p>IP地址基于逻辑，比较灵活，不受硬件限制，也容易记忆。MAC地址在一定程度上与硬件一致，基于物理，能够标识具体。这两种地址各有好处，使用时也因条件而采取不同的地址</p>
<h3 id="IP地址与MAC地址在互连网中的作用"><a href="#IP地址与MAC地址在互连网中的作用" class="headerlink" title="IP地址与MAC地址在互连网中的作用"></a>IP地址与MAC地址在互连网中的作用</h3><p>既然每个以太网设备在出厂时都有一个唯一的MAC地址了，那为什么还需要为每台主机再分配一个IP地址呢？或者说为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：（1）IP地址的分配是根据网络的拓朴结构，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。（2）当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。（3）无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到MAC地址上来完成的。</p>
<p>这是由组网方式决定的，如今比较流行的接入Internet的方式（也是未来发展的方向）是把主机通过局域网组织在一起，然后再通过交换机和 Internet相连接。这样一来就出现了如何区分具体用户，防止盗用的问题。由于IP只是逻辑上标识，任何人都随意修改，因此不能用来标识用户；而 MAC地址则不然，它是固化在网卡里面的。从理论上讲，除非盗来硬件（网卡），否则是没有办法冒名顶替的（注意：其实也可以盗用，后面将介绍）。<br>基于MAC地址的这种特点，局域网采用了用MAC地址来标识具体用户的方法。注意：具体实现：在交换机内部通过“表”的方式把MAC地址和IP地址一一对应，也就是所说的IP、MAC绑定。<br>具体的通信方式：接收过程，当有发给本地局域网内一台主机的数据包时，交换机接收下来，然后把数据包中的IP地址按照“表”中的对应关系映射成MAC地址，转发到对应的MAC地址的主机上，这样一来，即使某台主机盗用了这个IP地址，但由于他没有这个MAC地址，因此也不会收到数据包。发送过程和接收过程类似，限于篇幅不叙述。<br>综上可知，只有IP而没有对应的MAC地址在这种局域网内是不能上网的，于是解决了IP盗用问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/NET_address/" data-id="cjm8rmk3i000frguz0fk2377z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/16/OS/" class="article-date">
  <time datetime="2018-09-16T05:43:29.232Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/16/OS/">Linux命令运行的基本过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>shell不断询问是否有键盘输入，用户以enter结束键盘输入后，shell程序以空格为分隔符，得到”ls”，”-l”，”*.c”，三个字符串</p>
<p>shell发现第三个字符串包含”*”通配符，就会在当前路径(或指定路径)下搜索满足这个通配符的文件。有bar.c和foo.c两个文件，然后展开成{“ls”，”-l”，”bar.c”，”foo.c”}四个字符串，并保存在argv这个二维字符数组中，并赋值argc为4</p>
<p>shell然后搜索PATH这个全局变量保存的路径，寻找一个叫”ls”的命令。如果存在，则fork()一个子进程，调用exec()加载运行ls命令。ls的main(int argc, string ** argv)函数的参数就是从shell那里得来的。若不存在就会提示用户”command not found”</p>
<p>ls程序执行后，会分析argc和argv，”-l”表示这是一个选项开关，表明用户想得到文件的详细信息，并把这个开关量保存，以便最后输出的时候选择信息的格式</p>
<p>ls执行完既定的步骤后，退出并返回退出码，若成功则返回0，否则根据错误的不同返回不同的非零数字</p>
<p>shell在得到成功退出码后，继续等待用户输入</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/16/OS/" data-id="cjm8rmk3p000nrguzz3g6c0mo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/27/Golang_GC/">学习Golang之GC</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_practice/">学习Golang之实战</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Redis4/">Redis之事务</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_defer/">学习Golang之defer</a>
          </li>
        
          <li>
            <a href="/2018/09/25/Redis3/">Redis之应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>