<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>面向对象之构造函数析构函数 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="构造函数• 构造函数是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型• 而与其他成员函数相同的是，构造函数也有形参表（可能为空）和 函数体。• 一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参• 构造函数是类的特殊非静态成员函数，用于初始化其类类型的对象• 构造函数无名且不能直接调用。它们在初始化发生时调用，且它们按照初始化的规则选择。">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象之构造函数析构函数">
<meta property="og:url" content="http://yoursite.com/2018/09/18/OOP_cons/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="构造函数• 构造函数是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型• 而与其他成员函数相同的是，构造函数也有形参表（可能为空）和 函数体。• 一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参• 构造函数是类的特殊非静态成员函数，用于初始化其类类型的对象• 构造函数无名且不能直接调用。它们在初始化发生时调用，且它们按照初始化的规则选择。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-09-19T03:06:09.357Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象之构造函数析构函数">
<meta name="twitter:description" content="构造函数• 构造函数是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型• 而与其他成员函数相同的是，构造函数也有形参表（可能为空）和 函数体。• 一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参• 构造函数是类的特殊非静态成员函数，用于初始化其类类型的对象• 构造函数无名且不能直接调用。它们在初始化发生时调用，且它们按照初始化的规则选择。">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-OOP_cons" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/OOP_cons/" class="article-date">
  <time datetime="2018-09-18T06:56:47.577Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面向对象之构造函数析构函数
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>• 构造函数是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型<br>• 而与其他成员函数相同的是，构造函数也有形参表（可能为空）和 函数体。<br>• 一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参<br>• 构造函数是类的特殊非静态成员函数，用于初始化其类类型的对象<br>• 构造函数无名且不能直接调用。它们在初始化发生时调用，且它们按照初始化的规则选择。<br>    ○ 无 explicit 指定符的构造函数是转换构造函数。<br>    ○ 有 constexpr 指定符的函数令其类型为字面类型 (LiteralType) 。<br>    ○ 可以不带任何参数调用的构造函数是默认构造函数。<br>    ○ 可以接收同类型的另一对象为参数的构造函数是复制构造函数和移动构造函数</p>
<h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p>列表中成员初始化器的顺序是不相关的：初始化的实际顺序如下： </p>
<pre><code>1. 若构造函数是最终导出类的，则按基类声明的深度优先、从左到右遍历顺序（从左到右指的是基指定符列表中的出现）初始化虚基类
2. 然后，以从如它们出现于此类的基指定符列表的左到右顺序初始化直接基类
3. 然后，以类定义中__声明顺序__初始化非静态成员
4. 最后，执行构造函数体
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"> </span><br><span class="line">struct Base &#123;</span><br><span class="line">    int n;</span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line">struct Class : public Base</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char x;</span><br><span class="line">    unsigned char y;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg;</span><br><span class="line">    std::fstream f;</span><br><span class="line">    std::string s;</span><br><span class="line"> </span><br><span class="line">    Class ( int x )</span><br><span class="line">      : Base &#123; 123 &#125;, // 初始化基类</span><br><span class="line">        x ( x ),      // x （成员）以 x （参数）初始化</span><br><span class="line">        y &#123; 0 &#125;,      // y 初始化为 0</span><br><span class="line">        f&#123;&quot;test.cc&quot;, std::ios::app&#125;, // 这在初始化 m 和 lg 后发生</span><br><span class="line">        s(__func__),   //__func__ 可用，因为初始化器列表是构造函数的一部分</span><br><span class="line">        lg ( m ),      // lg 使用已经初始化的 m</span><br><span class="line">        m&#123;&#125;            // m 在 lg 前初始化，即使它在此最后出现</span><br><span class="line">    &#123;&#125;                // 空复合语句</span><br><span class="line"> </span><br><span class="line">    Class ( double a )</span><br><span class="line">      : y ( a+1 ),</span><br><span class="line">        x ( y ), // x 将在 y 前初始化，其值不确定</span><br><span class="line">        lg ( m )</span><br><span class="line">    &#123;&#125; // 基类构造函数不出现于列表，它被默认初始化（与假如使用 Base() 不同，那是值初始化）</span><br><span class="line"> </span><br><span class="line">    Class()</span><br><span class="line">    try // 函数 try 块始于包含初始化器列表的函数体前</span><br><span class="line">      : Class( 0.0 ) // 委托构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化出现异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    Class c;</span><br><span class="line">    Class c1(1);</span><br><span class="line">    Class c2(0.1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数<br>调用顺序</p>
<p>基类构造函数、对象成员构造函数、派生类本身的构造函数  </p>
<p>派生类本身的析构函数、对象成员析构函数、基类析构函数（与构造顺序正好相反）</p>
<p>3、特例<br>局部对象，在退出程序块时析构<br>静态对象，在定义所在文件结束时析构<br>全局对象，在程序结束时析构<br>继承对象，先析构派生类，再析构父类<br>对象成员，先析构类对象，再析构对象成员</p>
<p>下面归纳一下什么时候调用构造函数和析构函数：<br>1) 在全局范围中定义的对象(即在所有函数之外定义的对象)，它的构造函数在文件中的所有函数(包括main函数)执行之前调用。但如果一个程序中有多个文件，而不同的文件中都定义了全局对象，则这些对象的构造函数的执行顺序是不确定的。当main函数执行完毕或调用exit函数时(此时程序终止)，调用析构函数。</p>
<p>2) 如果定义的是局部自动对象(例如在函数中定义对象)，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。</p>
<p>3) 如果在函数中定义静态(static )局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。</p>
<h4 id="为什么构造不能为虚"><a href="#为什么构造不能为虚" class="headerlink" title="为什么构造不能为虚"></a>为什么构造不能为虚</h4><p>第一点，没有意义。虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。虚函数的作用在于通过父类的指针或引用来调用父类或子类的那个成员函数，而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。对象的构造则是由编译器完成的，由于在创建一个对象的过程中，涉及到资源的创建，类型的确定。要创建一个对象，你需要知道对象的完整信息。特别是，你需要知道你想要创建的确切类型。而这些是不能在运行过程中确定的，需要在编译的过程中就确定下来。</p>
<p>第二点，时间上矛盾。虚函数对应一个指向vtable虚函数表的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。所以，这个调用也是违背先实例化后调用的准则</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h4 id="为什么析构函数要虚"><a href="#为什么析构函数要虚" class="headerlink" title="为什么析构函数要虚"></a>为什么析构函数要虚</h4><p>若类为多态（声明或继承至少一个虚函数），且其析构函数非虚，通过指向基类指针删除对象引发未定义行为，无关乎若不调用派生的虚构函数是否导致资源泄漏————实际执行时通常发生的是对象的派生成分没被销毁，于是造成一个诡异的“局部销毁”对象</p>
<p>相反，虽然虚析构函数是不继承的，若基类声明器其析构函数为 virtual ，则导出的析构函数始终覆写它。这使得可以通过指向基类的指针 delete 动态分配的多态类型对象</p>
<p>由于虚函数是释放对象的时候才执行的，所以一开始也就无法确定析够函数的。而去由于析构的过程中，是先析构子类对象，后析构父类对象。所以，需要通过虚函数来指引子类对象。所以，如果不设置成虚函数的话，析构函数是无法执行子类的析构函数的</p>
<p>• 因此，一条有用的方针，是任何基类的虚函数必须为公开且虚，或受保护且非虚<br>    ○ Effective C++: 带有多态性质的基类应该声明一个虚析构函数<br>并非所有基类的设计目的都是为了多态用途，如条款6和条款47，因此他们不需要虚析构函数</p>
<h3 id="构造函数或者析构函数中调用虚函数会怎样"><a href="#构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="构造函数或者析构函数中调用虚函数会怎样"></a>构造函数或者析构函数中调用虚函数会怎样</h3><p>基类的构造函数中又调用了虚函数saleRecord()， 在此，你认为基类构造函数中所调用的虚函数saleRecord的实现版本是哪一个呢，是基类的实现版本还是派生类B的实现版本呢？</p>
<p>详情见《effective C++》第九条款 </p>
<p>也是两点，第一点，在创建派生类的时候，基类先于派生类被构造，编译器或者程序其实目光是很短浅的或者说是很现实的，在调用基类构造函数的时候，它并不知道你最终是要创建一个基类还是派生类，它只要把现在手头上的工作做好——创建一个基类。因此它没有办法调用派生类B的实现版本。</p>
<p>第二点，假设它可以调用派生类B的实现版本。此时，又会发生什么呢。从意图上讲，我们要调用虚函数的不同版本，从根本上讲，是要对不同的数据进行操作，这样函数才有意义。比如说基类的虚函数版本是对基类的数据进行操作， 派生类的虚函数版本是对派生类的数据进行操作。 但此时，派生类的构造函数还没有调用，派生类的数据成员也不会有相应的初始化，这时候对派生类的数据成员操作完全是无意义的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/18/OOP_cons/" data-id="cjm8rmk3q000orguz8jo77f8f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/09/18/learnDB_index1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据库的学习之索引（二）
        
      </div>
    </a>
  
  
    <a href="/2018/09/18/datastruct_searchtree/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据结构和算法之查找树</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/27/Golang_GC/">学习Golang之GC</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_practice/">学习Golang之实战</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Redis4/">Redis之事务</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_defer/">学习Golang之defer</a>
          </li>
        
          <li>
            <a href="/2018/09/25/Redis3/">Redis之应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>