<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Golang_GC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/27/Golang_GC/" class="article-date">
  <time datetime="2018-09-27T13:07:00.139Z" itemprop="datePublished">2018-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/27/Golang_GC/">学习Golang之GC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Golang的一些特性</p>
<h3 id="自动垃圾回收"><a href="#自动垃圾回收" class="headerlink" title="自动垃圾回收"></a>自动垃圾回收</h3><ul>
<li>函数多返回值<br>多值返回仅动态语言Python有此特性</li>
<li>错误处理</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/27/Golang_GC/" data-id="cjmkoxr690003g4uzg7ms0laj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Golang_practice" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/26/Golang_practice/" class="article-date">
  <time datetime="2018-09-26T14:17:10.994Z" itemprop="datePublished">2018-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/26/Golang_practice/">学习Golang之实战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说了那么多理论，怎么不实操一下。</p>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>贝壳一面（09.20）的面试官下了我的github代码，“抱怨”我怎么不用包管理器。我们知道近期官方已经推出了go module</p>
<p>先了解一下什么是模块，模块 ( module ) 是相关 go 包的集合，是是源代码交换 ( interchange ) 和版本化控制的基本单元</p>
<ul>
<li>「模块根目录」 ( Module root ) : 包含了名为 go.mod 文件的目录</li>
<li>「模块路径」 ( Module path ) : 与模块根目录对应的导入路径的前缀</li>
<li>「主模块」( Main module ) : 包行了运行 go 命令的所在目录的模块</li>
</ul>
<p>项目目录下，执行以下命令初始化<br>$ go mod init<br>执行以下命令会自动分析项目里的依赖关系同步到go.mod文件中，同时创建go.sum文件<br>$ go mod tidy<br>以上的管理依赖管理操作，所以依赖包还是在GOPATH/src目录下，go module 当然可以把包直接放在当前项目中管理<br>$ go mod vendor<br>直接使用这个命令就可以把GOPATH/src目录下的依赖包同步到当前项目目录中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/26/Golang_practice/" data-id="cjmkoxr690004g4uzeshrpv2g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/26/Redis4/" class="article-date">
  <time datetime="2018-09-26T14:06:38.457Z" itemprop="datePublished">2018-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/26/Redis4/">Redis之事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p>京东一面问及Redis的原子性，没答上来。。。</p>
<p>redis原子性操作的实现原理在于redis底层使用单线程操作</p>
<p>Redis事务的实现原理：</p>
<ol>
<li>批量操作在发送 EXEC 命令前被放入队列缓存</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令都不会被执行</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/26/Redis4/" data-id="cjmkoxr6f000cg4uznboh7gw4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Golang_defer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/26/Golang_defer/" class="article-date">
  <time datetime="2018-09-26T11:27:59.582Z" itemprop="datePublished">2018-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/26/Golang_defer/">学习Golang之defer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Defer-Panic-and-Recover"><a href="#Defer-Panic-and-Recover" class="headerlink" title="Defer, Panic, and Recover"></a>Defer, Panic, and Recover</h3><p>go有通常的控制流机制: if, for, switch, goto。它还有go语句以在单独的 goroutine 中运行代码。这里我想讨论一些比较不常见的问题：Defer, Panic, and Recover</p>
<p>3个重要关键字defer、panic、recover<br>    defer是函数结束后执行，呈先进后出；<br>    panic是程序出现无法修复的错误时使用，但会让defer执行完；<br>    recover会修复错误，不至于程序终止。当不确定函数不会出错时使用defer+recover</p>
<p>“defer”语句调用的函数将被推迟到其外围函数返回时执行，不论是因为该外围函数执行了 return 语句，到达了其函数体的末尾， 还是因为其对应的Go程进入了恐慌过程</p>
<p> 任何被 F 推迟的函数会在 F 返回给其调用者前执行</p>
<h3 id="Defer、Return之间执行顺序"><a href="#Defer、Return之间执行顺序" class="headerlink" title="Defer、Return之间执行顺序"></a>Defer、Return之间执行顺序</h3><p>京东一面（0926）真题，一脸懵逼</p>
<p>接下来是三个例题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// f 返回 1</span><br><span class="line">func f() (result int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        result++</span><br><span class="line">    &#125;()</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里，若被推迟的函数为函数字面，即defer后面的函数，而其外围函数在其作用域中的函数字面内拥有 已命名结果形参，即result，则被推迟的函数可在该结果形参被返回前访问并更改。 若被推迟函数拥有任何返回值，则它们会在该函数完成时丢弃</p>
</blockquote>
<p>要理解上面这段话，就要了解defer的实现方式，大致就是在defer出现的地方，插入指令CALL runtime.deferproc，然后在函数返回之前的地方，插入指令CALL runtime.deferreturn。再就是明确go返回值的方式跟C是不一样的，为了支持多值返回，go是用栈返回值的，而C是用寄存器。<br>最最重要的一点就是： <em>return xxx这一条语句并不是一条原子指令!</em><br>整个return过程，没有defer之前，先在栈中写一个值，这个值会被当作返回值，然后再调用RET指令返回。return xxx语句汇编后是先给返回值赋值，再做一个空的return，( 赋值指令 ＋ RET指令)。defer的执行是被插入到return指令之前的，有了defer之后，就变成了(赋值指令 + CALL defer指令 + RET指令)。而在CALL defer函数中，有可能将最终的返回值改写了…也有可能没改写。总之，如果改写了，那么看上去就像defer是在return xxx之后执行的~</p>
<p>于是我们有如下改写规则<br>改写规则是将return语句分开成两句写，return xxx会被改写成:<br>返回值 = xxx<br>调用defer函数<br>空的return</p>
<p>当然，这是在已命令结果形参下，如果不是，则不会发生修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func f() (result int) &#123;</span><br><span class="line">     result = 0  //return语句不是一条原子调用，return xxx其实是赋值＋RET指令</span><br><span class="line">     func() &#123; //defer被插入到return之前执行，也就是赋返回值和RET指令之间</span><br><span class="line">         result++</span><br><span class="line">     &#125;()</span><br><span class="line">     return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看两个例题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// f 返回 1</span><br><span class="line">func f() (r int) &#123;</span><br><span class="line">     t := 1</span><br><span class="line">     defer func() &#123;</span><br><span class="line">       t = t + 5</span><br><span class="line">     &#125;()</span><br><span class="line">     return t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>⬇<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func f() (r int) &#123;</span><br><span class="line">     t := 1</span><br><span class="line">     r = t //赋值指令</span><br><span class="line">     func() &#123;        //defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span><br><span class="line">         t = t + 5</span><br><span class="line">     &#125;</span><br><span class="line">     return        //空的return指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// f 返回 1</span><br><span class="line">func f() (r int) &#123;</span><br><span class="line">    defer func(r int) &#123;</span><br><span class="line">          r = r + 5</span><br><span class="line">    &#125;(r)</span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⬇<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func f() (r int) &#123;</span><br><span class="line">     r = 1  //给返回值赋值</span><br><span class="line">     func(r int) &#123;        //这里改的r是传值传进去的r，不会改变要返回的那个r值</span><br><span class="line">          r = r + 5</span><br><span class="line">     &#125;(r)</span><br><span class="line">     return        //空的return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/26/Golang_defer/" data-id="cjmkoxr680002g4uz4f6o59h1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/Redis3/" class="article-date">
  <time datetime="2018-09-25T13:20:12.171Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/Redis3/">Redis之应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis提供了两种方式来作消息队列。<br>  一个是使用生产者消费模式模式，<br>  另一个就是发布订阅者模式。 </p>
<p>前者会让一个或者多个客户端监听消息队列，一旦消息到达，消费者马上消费，谁先抢到算谁的，如果队列里没有消息，则消费者继续监听。<br>后者也是一个或多个客户端订阅消息频道，只要发布者发布消息，所有订阅者都能收到消息，订阅者都是平等的。</p>
<p>redis 消息推送（基于分布式 pub/sub）多用于实时性较高的消息推送，并不保证可靠。<br>其他的mq和kafka保证可靠但有一些延迟（非实时系统没有保证延迟）。redis-pub/sub断电就清空，而使用redis-list作为消息推送虽然有持久化，但是又太弱智，也并非完全可靠不会丢。</p>
<p>另外一点，redis 发布订阅除了表示不同的 topic 外，并不支持分组，比如kafka中发布一个东西，多个订阅者可以分组，同一个组里只有一个订阅者会收到该消息，这样可以用作负载均衡</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/25/Redis3/" data-id="cjmkoxr6e000bg4uz9i73vzht" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/Redis2/" class="article-date">
  <time datetime="2018-09-25T08:20:00.071Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/Redis2/">Redis之简单介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在不会Redis简直不敢和人打招呼。Redis以其性能和并发著称。所以用它做缓存实在是再好不过。为什么Redis那么快？</p>
<ul>
<li>纯内存操作：完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li>
</ul>
<p><img src="images/Redis2.bmp" alt="内存"></p>
<ul>
<li>单线程操作，避免了频繁的上下文切换。采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
</ul>
<p>这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行</p>
<ul>
<li>采用了非阻塞I/O多路复用机制。使用多路I/O复用模型，非阻塞IO；内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</li>
</ul>
<p>此外还有</p>
<ul>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</p>
</li>
</ul>
<p>以下也是你应该知道的几种模型，祝你的面试一臂之力！<br>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；<br>2、多进程模型：Oracle（Linux版本）；<br>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：<br>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。<br>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。<br>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/25/Redis2/" data-id="cjmkoxr6d000ag4uz8t1eivmv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/24/Redis/" class="article-date">
  <time datetime="2018-09-24T12:36:01.231Z" itemprop="datePublished">2018-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/24/Redis/">Redis之持久化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。<br>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug </p>
<p>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。这在用Redis实现缓存时用到</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。<br>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure></p>
<p>快照功能并不是非常耐久（dura ble）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/24/Redis/" data-id="cjmkoxr6c0008g4uz6ifyvp1t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NET_ssh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/24/NET_ssh/" class="article-date">
  <time datetime="2018-09-24T07:43:12.944Z" itemprop="datePublished">2018-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/24/NET_ssh/">计算机网络复习之远程登陆</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/24/NET_ssh/" data-id="cjmkoxr6b0006g4uzmjel0umh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Golang_basic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/23/Golang_basic/" class="article-date">
  <time datetime="2018-09-23T13:43:26.006Z" itemprop="datePublished">2018-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/23/Golang_basic/">学习Golang之基本类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>数组的大小是其类型的一部分，而切片可以具有动态大小，因为它们是围绕数组的封装</p>
<p>类似于数组，切片是可索引的且拥有一个长度。切片 s 的长度可通过内建函数 len获取；不同于数组的是，切片可在执行过程中被改变， 其元素可通过整数（§下标） 0 到 len(s)-1 寻址。 给定元素的切片下标可能小于它在其基本数组中的下标</p>
<p>切片一旦初始化，就总是伴随着一个包含其元素的基本数组。 因此，切片与其数组及其它本数组的切片共享存储； 与此相反，不同的数组总是表示其不同的存储</p>
<p>切片的基本数组可扩展其切片的结尾。容量 是该扩展的量度： 它是切片的长度和切片往后数组的长度之和；长度达到其容量的切片可通过从原切片 （§Slices）‘切下’一个新的来创建。 切片 a 的容量可使用内建函数 cap(a) 获取</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go虽然有指针，但是没有指针算数，不能对其进行加减。但可以把指针值赋给另一个指针，因此Go的指针更像是C++的引用，却又没有C++中引用初始化后不能重新赋值的限制</p>
<p>指针在Go中是“安全”的，指针无法指向任意的内存区域，缓冲区溢出的问题不会发生。但注意，解引用一个空指针同样能导致Go程序崩溃。</p>
<p>指针的使用是和内存的分配紧密相关的。C&amp;C++需要手动管理内存，然而Go使用垃圾收集器自动管理内存，这样就减少很多使用指针上的操心。首先我们再也不需要显示释放内存，悬挂指针（dangling pointer，指向已释放的内存）以及多次释放同一个指针指向内存的问题就不会发生。我们甚至不用担心内存是在栈上分配的还是堆上分配的。C++中的各种智能指针std::unique_ptr,std::shared_ptr, std::weak_ptr, std::auto_ptr也用不上了。一切都由Go的运行时系统帮助处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/23/Golang_basic/" data-id="cjmkoxr660001g4uzvh5daap7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Golang_routine" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/22/Golang_routine/" class="article-date">
  <time datetime="2018-09-22T01:25:17.623Z" itemprop="datePublished">2018-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/22/Golang_routine/">学习Golang之协程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>go语言倡导使用消息传递来共享内存，引入了goroutine概念，这是一个协程，更轻量级的线程。与channel搭配使用</p>
<ul>
<li>基于Thread的轻量级协程</li>
<li>通过channel来进行协程间的消息传递</li>
<li>只暴露协程，屏蔽线程操作的接口</li>
</ul>
<h3 id="Goroutine的设计原理"><a href="#Goroutine的设计原理" class="headerlink" title="Goroutine的设计原理"></a>Goroutine的设计原理</h3><p>在操作系统的系统线程（OS Thread）和编程语言的用户态线程（User Thread）之间，实际上存在3中线程对应模型：</p>
<ul>
<li>(M:1)————多个（M）用户态的线程对应一个系统线程，它可以做快速的上下文切换，缺点是不能有效利用多核CPU。</li>
<li>(1:1)————一个用户态的线程对应一个系统线程，它可以利用多核机制，但上下文切换需要消耗额外的资源<br>Golang的做法</li>
<li>(M:N)————Golang采取了一种多对多的方案。M个用户线程对应N个系统线程，缺点是增加了调度器的实现难度</li>
</ul>
<p>角色：<br>M: 代表了系统线程，由操作系统管理<br>G：协程Goroutine的实体，包括了调用栈，指令指针以及重要的调度Goroutine信息，例如阻塞它的任何channel等，由程序员创建<br>P：处理器Processor，衔接M和G的调度，执行G的上下文环境，它负责将等待执行的G与M对接，每个P会维护一个本地的Goroutine队列。<br>除了每个P拥有一个本地的go routine队列外，还存在一个全局的go routine队列</p>
<p><img src="images/Golang_routine.bmp" alt="协程"></p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>我们可以看到图中有两个M，即两个OS Thread线程，分别对应一个P，每一个P有负责调度多个G。如此一来，就组成的Goroutine运行时的基本结构</p>
<p>P的数量在初始化，由环境变量中的GOMAXPROCS决定，通常来说它是和核心数对应，例如在4Core的服务器上回启动4个线程。它其实也就代表了真正的并发度，即有多少个Goroutine可以同时运行。</p>
<p>G会有很多个，每个P会将Goroutine从一个就绪的队列中做pop操作，这个队列称之为runqueue。</p>
<p>为了减小锁mutex的竞争，通常情况下每个P都会负责一个自己的队列。Go调度器曾经的一个版本，只用一个通过mutex来保护的全局runqueue，线程们经常被阻塞来等待mutex被解除阻塞。当你有许多32核的机器而且想尽可能地压榨它们的性能时，情况就会变得相当坏。</p>
<p>如果G的数量超出了M的处理能力，且还有空余P的话，runtime就会自动创建新的M；</p>
<p>M拿到P后才能干活，取G的顺序：本地队列&gt;全局队列&gt;其他P的队列（窃取），如果所有队列都没有可用的G，M会归还P并进入休眠</p>
<h4 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h4><p>为什么一定要有上下文P？我们能不能丢掉上下文P而仅仅把runqueue放到系统线程上？不尽然。我们用上下文P的原因是如果正在运行的线程因为某种原因需要阻塞的时候，我们可以把这些上下文移交给其它线程。</p>
<p>这种阻塞，有三种情况，G发生上下文P切换条件：</p>
<ul>
<li>系统调用（挂起）；</li>
</ul>
<p><img src="Golang_routine.bmp" alt="切换"></p>
<p>在Goroutine需要执行一个系统调用时，由于M0是一个线程，所以必须等待它执行完才能执行其他的Goroutine。当一个新的Goroutine产生，M0需要保证会有另外的一个M1能够执行这个G，简单来说，当一个M0进行系统调用，需要保证有另外的一个M1能够继续执行Go代码。</p>
<p>这个处于系统调用中的线程M0将会保持在这个导致系统调用的goroutine上，因为从技术上来说，它仍然在执行，虽然阻塞在OS里了。</p>
<p>当系统调用返回时，M0需要找到一个对应的P，以便能够运行Goroutine，它首先会尝试从其他线程中窃取一个P，如果不成功，它会将Goroutine放在一个全局的队列中,并将自己放在线程池thread cache中或者转入睡眠状态。</p>
<ul>
<li>读写channel；</li>
<li>gosched主动放弃，会将G扔进全局队列；</li>
</ul>
<h4 id="如何窃取"><a href="#如何窃取" class="headerlink" title="如何窃取"></a>如何窃取</h4><p>这里有篇paper来描述这个设计：work-steal。简单来说，当队列不平衡时，会从其他队列中截取一部分Goroutine到P上进行调度。</p>
<p>除了上下文了P会被窃取之外，Goroutine也是会被窃取的，当一个上下文运行完要被调度的所有goroutines的时候。如果各个上下文的runqueue里的工作的数目不均衡，改变就会发生了，否则会导致一个上下文在执行完它的runqueue后就会结束，尽管系统中仍然有许多工作要执行。所以为了保持运行Go代码，一个上下文能够从全局runqueue中获取goroutines，但是如果全局runqueue中也没有goroutines了，那么上下文就不得不从其它地方获取goroutines了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/22/Golang_routine/" data-id="cjmkoxr6a0005g4uzdrhjpxql" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/27/Golang_GC/">学习Golang之GC</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_practice/">学习Golang之实战</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Redis4/">Redis之事务</a>
          </li>
        
          <li>
            <a href="/2018/09/26/Golang_defer/">学习Golang之defer</a>
          </li>
        
          <li>
            <a href="/2018/09/25/Redis3/">Redis之应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>